<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>计算机体系结构 on EVER BLOG</title>
    <link>http://localhost:1313/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</link>
    <description>Recent content in 计算机体系结构 on EVER BLOG</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 08 May 2025 15:12:23 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Computer Architecture Part2</title>
      <link>http://localhost:1313/posts/2024/12/computer-architecture-part2/</link>
      <pubDate>Thu, 05 Dec 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/2024/12/computer-architecture-part2/</guid>
      <description>&lt;h2 id=&#34;流水线-pipeline&#34;&gt;流水线（Pipeline）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%b5%81%e6%b0%b4%e7%ba%bf-pipeline&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;将单条指令拆分成多个阶段执行后，当其执行到后一个阶段时，前一个阶段的硬件处于空闲状态，此时再发射一条指令从而复用硬件，就像工业流水线生产一样。 &lt;br/&gt;&#xA;更多并发 → 更高的指令吞吐量 &lt;br/&gt;&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;http://localhost:1313/imgs/comp-arch/pipeline.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;停顿-stall-流水线停止前进的情况&#34;&gt;停顿（Stall）：流水线停止前进的情况&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%81%9c%e9%a1%bf-stall-%e6%b5%81%e6%b0%b4%e7%ba%bf%e5%81%9c%e6%ad%a2%e5%89%8d%e8%bf%9b%e7%9a%84%e6%83%85%e5%86%b5&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;停顿 = 指令等待其源操作数可用 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;停止所有上游阶段 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;清空所有下游阶段 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;禁用 PC 和 IF/ID 锁存器；确保停顿的指令保持在其当前阶段，在停顿指令之后的流水线阶段插入“无效”指令或空操作（称为“气泡”）。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;资源竞争-resource-contention&#34;&gt;资源竞争（Resource contention）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e8%b5%84%e6%ba%90%e7%ab%9e%e4%ba%89-resource-contention&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;当两个流水线阶段中的指令需要使用同一资源时发生 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;消除引起资源竞争的原因,复制资源或增加资源吞吐量 &lt;br/&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分离指令和数据存储器（缓存） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;为内存结构增加多个端口 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;检测资源竞争并暂停一个争用阶段 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;寄存器文件可在同一周期读写：写入发生在周期上半段, 读取发生在周期下半段, 但读/写操作只有半个时钟周期完成。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;指令间的依赖-dependences&#34;&gt;指令间的依赖（Dependences）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%8c%87%e4%bb%a4%e9%97%b4%e7%9a%84%e4%be%9d%e8%b5%96-dependences&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;数据依赖（Data）&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Flow dependence（写后读） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;figure&gt;&lt;img data-src=&#34;http://localhost:1313/imgs/comp-arch/raw.png&#34;&#xA;             data-action=&#34;zoom&#34;&#xA;             class=&#34;lazyload&#34;/&gt;&#xA;    &lt;/figure&gt;&#xA; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Anti dependence（读后写） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;figure&gt;&lt;img data-src=&#34;http://localhost:1313/imgs/comp-arch/war.png&#34;&#xA;             data-action=&#34;zoom&#34;&#xA;             class=&#34;lazyload&#34;/&gt;&#xA;    &lt;/figure&gt;&#xA; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Output dependence（写后写） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;figure&gt;&lt;img data-src=&#34;http://localhost:1313/imgs/comp-arch/waw.png&#34;&#xA;             data-action=&#34;zoom&#34;&#xA;             class=&#34;lazyload&#34;/&gt;&#xA;    &lt;/figure&gt;&#xA; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;解决方案&lt;/p&gt;&#xA;&lt;p&gt;后两种依赖：只需要在最后阶段、按程序顺序写入目标寄存器 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;处理 Flow 依赖的六种基本方法： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;检测并等待寄存器中值可用 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;检测并转发/旁路数据给依赖指令 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;检测并在软件层面消除依赖（无需硬件检测） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;检测并重新排序，使独立指令先执行 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;预测所需值，进行“推测执行”，然后验证 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;使用其他方式（如细粒度多线程），不需检测 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;可以添加一个硬件单元来检测依赖。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;控制依赖（Control）&lt;/p&gt;&#xA;&lt;p&gt;若取出的指令是控制流指令： &lt;br/&gt;&#xA;如何确定下一条 Fetch 的 PC？使用分支预测器。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;长延迟-多周期-操作-long-latency-operations&#34;&gt;长延迟（多周期）操作（Long-latency operations）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e9%95%bf%e5%bb%b6%e8%bf%9f-%e5%a4%9a%e5%91%a8%e6%9c%9f-%e6%93%8d%e4%bd%9c-long-latency-operations&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;由于长延迟指令占用硬件而造成的等待。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;数据转发-data-forwarding&#34;&gt;数据转发（Data Forwarding）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e8%bd%ac%e5%8f%91-data-forwarding&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;一旦结果可用，即将其转发给依赖的指令，从而降低停顿时间。 &lt;br/&gt;&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;http://localhost:1313/imgs/comp-arch/data-forwarding.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;异常与中断-exceptions-and-interrupts&#34;&gt;异常与中断（Exceptions and Interrupts）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%bc%82%e5%b8%b8%e4%b8%8e%e4%b8%ad%e6%96%ad-exceptions-and-interrupts&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;程序执行过程中的“非计划”更改或中断: &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;异常（Exceptions）,源自程序内部的执行问题 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;中断（Interrupts）,来自需要处理的外部事件 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;处理异常和中断的共同步骤： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;停止当前程序 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;保存体系结构状态 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;处理异常/中断 → 切换到处理程序 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;（如可能且合理）返回程序执行 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;示例&#34;&gt;示例&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e7%a4%ba%e4%be%8b&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;&#xA;&lt;li&gt;异常：除以零、溢出、未定义操作码、访问保护错误、缺页错误等。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;中断：I/O 设备请求服务（如键盘输入、视频输入）、（周期性）系统定时器超时、电源故障、机器检查等。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;原因&#34;&gt;原因&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%8e%9f%e5%9b%a0&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;ul&gt;&#xA;&lt;li&gt;异常：来自当前运行线程内部 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;中断：来自线程外部 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;处理时机&#34;&gt;处理时机&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%a4%84%e7%90%86%e6%97%b6%e6%9c%ba&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;ul&gt;&#xA;&lt;li&gt;异常：在检测到且为非推测性异常时，立即处理 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;中断：在合适时机处理（除非是高优先级中断，如电源故障、机器检查） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;优先级：进程（异常），依赖情况（中断） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;处理上下文：进程（异常），系统（中断） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;保持精确以处理异常-中断-precise-exceptions-interrupts&#34;&gt;保持精确以处理异常/中断（Precise Exceptions/Interrupts）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e4%bf%9d%e6%8c%81%e7%b2%be%e7%a1%ae%e4%bb%a5%e5%a4%84%e7%90%86%e5%bc%82%e5%b8%b8-%e4%b8%ad%e6%96%ad-precise-exceptions-interrupts&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;保持精准是冯诺依曼架构成功的关键之一，如果不能做到这一点，调试程序将非常困难，对软件开发来说将是一种挑战。 &lt;br/&gt;&#xA;顺序提交指令的结果是保持程序正确和调试程序精准的关键。 &lt;br/&gt;&#xA;当准备处理异常/中断时，体系结构状态应保持一致（精确） &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;所有前面的指令应已完全完成 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;之后的指令不应已完成 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;当检测到最早可提交的指令导致异常时，控制逻辑将： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;确保架构状态精确（寄存器文件、PC、内存） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;清空流水线中所有较新的指令 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;保存 PC 和寄存器（由 ISA 规定） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;重定向取指引擎到相应的异常处理程序 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;保证精确异常&#34;&gt;保证精确异常&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e4%bf%9d%e8%af%81%e7%b2%be%e7%a1%ae%e5%bc%82%e5%b8%b8&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;单周期机器，每条指令保证在一个周期内完成，没有违反程序语义的风险 &lt;br/&gt;&#xA;多周期机器，需要在控制 FSM 中增加特殊状态，引导到异常/中断处理器，仅在精确状态（如取下一条指令之前）切换到处理程序 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;寄存器&lt;/p&gt;&#xA;&lt;p&gt;EPC 寄存器：保存引发异常的 PC &lt;br/&gt;&#xA;Cause 寄存器：保存异常的原因 &lt;br/&gt;&#xA;异常处理程序地址：如0x80000180 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;重排序缓冲区-reorder-buffer-rob&#34;&gt;重排序缓冲区（Reorder Buffer，ROB）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e9%87%8d%e6%8e%92%e5%ba%8f%e7%bc%93%e5%86%b2%e5%8c%ba-reorder-buffer-rob&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;允许指令乱序完成，即提交，但在结果可见前进行排序，当指令被译码时，分配 ROB 中的下一个顺序条目，指令完成时，将结果写入 ROB 条目，当该条目是 ROB 中最老的且没有异常，其结果写入寄存器或内存 &lt;br/&gt;&#xA;ROB 是一个硬件结构，记录所有译码但尚未提交的指令信息 &lt;br/&gt;&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;http://localhost:1313/imgs/comp-arch/rob.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;http://localhost:1313/imgs/comp-arch/rob2.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;使用 ROB 的寄存器重命名&lt;/p&gt;&#xA;&lt;p&gt;输出和反依赖并非真实依赖, 虽然是同一寄存器名，实际表示无关的值，由于 ISA 中寄存器数量有限，造成了假依赖 &lt;br/&gt;&#xA;解决方案：将寄存器 ID 重命名为其在 ROB 中的条目 ID &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;寄存器 ID → ROB 条目 ID &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;架构寄存器 ID → 物理寄存器 ID &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;使用 ROB ID 表示寄存器，消除假依赖，扩展寄存器数量 &lt;br/&gt;&#xA;寄存器重命名表（又称别名表） &lt;br/&gt;&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;http://localhost:1313/imgs/comp-arch/rat.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;使用 ROB 的顺序流水线&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;译码阶段（D）：访问寄存器文件和 ROB，分配 ROB 条目，若可执行则调度到执行单元 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;执行阶段（E）：允许乱序完成 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;完成阶段（R）：将结果写入 ROB &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;退休/提交阶段（W）：检查最老指令是否异常；若无，则写入寄存器文件或内存；否则，清空流水线并跳转异常处理 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;顺序调度/执行，乱序完成，顺序提交 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;figure&gt;&lt;img data-src=&#34;http://localhost:1313/imgs/comp-arch/rob3.png&#34;&#xA;             data-action=&#34;zoom&#34;&#xA;             class=&#34;lazyload&#34;/&gt;&#xA;    &lt;/figure&gt;&#xA; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;指令乱序执行-动态调度&#34;&gt;指令乱序执行（动态调度）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%8c%87%e4%bb%a4%e4%b9%b1%e5%ba%8f%e6%89%a7%e8%a1%8c-%e5%8a%a8%e6%80%81%e8%b0%83%e5%ba%a6&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;调度：将指令发送到功能单元的行为 &lt;br/&gt;&#xA;当前的执行模型： &lt;br/&gt;&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;http://localhost:1313/imgs/comp-arch/in-order-pipeline.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&#xA;可以看到不同处理单元所需的周期数是完全不同的，如果顺序发射指令可能会造成长时间的停顿。 &lt;br/&gt;&#xA;顺序流水线的问题： &lt;br/&gt;&#xA;未准备好的指令会阻塞其后的指令调度: &lt;br/&gt;&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;http://localhost:1313/imgs/comp-arch/in-order-dispatch.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;http://localhost:1313/imgs/comp-arch/out-of-order-dispatch.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;实现&#34;&gt;实现&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%ae%9e%e7%8e%b0&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;ol&gt;&#xA;&lt;li&gt;需要将使用某值的指令与生产者关联,使用寄存器重命名：为每个数据值分配一个“标签” &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;需要缓存指令，直到它们准备好执行,在重命名后插入保留站 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;指令需追踪源操作数的就绪状态,当一个值产生时，广播其“标签”,保留站中指令比较其源标签, 若匹配，则源值准备好 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;所有源值准备好时，调度指令到功能单元（FU）, 若多个指令准备好，每个 FU 需选择一个指令 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;figure&gt;&lt;img data-src=&#34;http://localhost:1313/imgs/comp-arch/rs.png&#34;&#xA;         data-action=&#34;zoom&#34;&#xA;         class=&#34;lazyload&#34;/&gt;&#xA;&lt;/figure&gt;&#xA; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;寄存器文件-rf-或寄存器别名表-rat&#34;&gt;寄存器文件（RF）或寄存器别名表（RAT）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%af%84%e5%ad%98%e5%99%a8%e6%96%87%e4%bb%b6-rf-%e6%88%96%e5%af%84%e5%ad%98%e5%99%a8%e5%88%ab%e5%90%8d%e8%a1%a8-rat&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;若 Valid 位为 1，表中值正确,否则，Tag 指出正确值的位置,Tag 是值将要被生产时的唯一标识符。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;所有执行单元都拥有保留站&#34;&gt;所有执行单元都拥有保留站&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%89%80%e6%9c%89%e6%89%a7%e8%a1%8c%e5%8d%95%e5%85%83%e9%83%bd%e6%8b%a5%e6%9c%89%e4%bf%9d%e7%95%99%e7%ab%99&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;h4 id=&#34;公共数据总线-cdb&#34;&gt;公共数据总线（CDB）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%85%ac%e5%85%b1%e6%95%b0%e6%8d%ae%e6%80%bb%e7%ba%bf-cdb&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;用于将计算出的值广播到可能需要它们的所有保留站 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;tomasulo-算法&#34;&gt;Tomasulo 算法&lt;a class=&#34;anchorjs-link&#34; href=&#34;#tomasulo-%e7%ae%97%e6%b3%95&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;ul&gt;&#xA;&lt;li&gt;若在重命名前有可用保留站： &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;将指令和重命名的操作数（值/标签）插入保留站 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;若无保留站，指令停顿 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;在保留站中，指令监听 CDB，等待其源操作数的标签 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;当标签匹配时，获取该值并保存在保留站中 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;当两个操作数都准备好后，指令准备调度 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;当指令完成后 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;申请 CDB &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;将带标签的值发送到 CDB（标签广播） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;寄存器文件连接到 CDB &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;寄存器包含表示最新写入者的标签 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;若标签匹配广播的标签，则写入值并设置有效位 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;回收重命名标签 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;系统中不再存在标签副本 → 可释放资源 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Computer Architecture Part1</title>
      <link>http://localhost:1313/posts/2024/11/computer-architecture-part1/</link>
      <pubDate>Fri, 15 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/2024/11/computer-architecture-part1/</guid>
      <description>&lt;h2 id=&#34;一种基本计算机模型&#34;&gt;一种基本计算机模型&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e4%b8%80%e7%a7%8d%e5%9f%ba%e6%9c%ac%e8%ae%a1%e7%ae%97%e6%9c%ba%e6%a8%a1%e5%9e%8b&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;冯·诺依曼模型&#xA;存储程序&#xA;顺序指令处理&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;内存（存储程序和数据）&lt;/li&gt;&#xA;&lt;li&gt;处理单元&lt;/li&gt;&#xA;&lt;li&gt;输入&lt;/li&gt;&#xA;&lt;li&gt;输出&lt;/li&gt;&#xA;&lt;li&gt;控制单元（控制指令执行的顺序）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;http://localhost:1313/imgs/comp-arch/von-neumann.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;http://localhost:1313/imgs/comp-arch/lc3.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;指令集&#34;&gt;指令集&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%8c%87%e4%bb%a4%e9%9b%86&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;ISA 是软件指令与硬件执行之间的接口&#xA;ISA指定了：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;内存组织&lt;/li&gt;&#xA;&lt;li&gt;地址空间（LC-3: 2^16，MIPS: 2^32）&lt;/li&gt;&#xA;&lt;li&gt;可寻址性（LC-3: 16 位，MIPS: 8 位）&lt;/li&gt;&#xA;&lt;li&gt;按字或按字节寻址&lt;/li&gt;&#xA;&lt;li&gt;寄存器集&#xA;LC-3 中有 8 个寄存器（R0 到 R7）&#xA;MIPS 中有 32 个寄存器&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;其包含：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;操作码&lt;/li&gt;&#xA;&lt;li&gt;数据类型&lt;/li&gt;&#xA;&lt;li&gt;寻址模式&lt;/li&gt;&#xA;&lt;li&gt;指令的长度和格式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;figure&gt;&lt;img data-src=&#34;http://localhost:1313/imgs/comp-arch/lc3-isa.png&#34;&#xA;         data-action=&#34;zoom&#34;&#xA;         class=&#34;lazyload&#34;/&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;指令主要分为三类：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;操作指令: 在 ALU 中执行操作&lt;/li&gt;&#xA;&lt;li&gt;数据移动指令: 从内存读取或写入到内存&lt;/li&gt;&#xA;&lt;li&gt;控制流指令: 改变执行顺序&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;操作指令&#34;&gt;操作指令&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%93%8d%e4%bd%9c%e6%8c%87%e4%bb%a4&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;在 LC-3 中，有三种操作指令：&#xA;NOT 是一元操作（一个源操作数), 执行按位非（bitwise NOT）, ADD 和 AND 是二元操作（两个源操作数）, ADD 是二进制补码加法, AND 是按位与 SR1 &amp;amp; SR2&#xA;在 MIPS 中，操作指令更多:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;大多数 R 类型指令（它们是二元操作）,例如：add，and，nor，xor……&lt;/li&gt;&#xA;&lt;li&gt;R 类型操作指令的 I 类型版本（即一个立即数操作数）&lt;/li&gt;&#xA;&lt;li&gt;F 类型操作， 即浮点操作&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;数据移动指令和寻址模式&#34;&gt;数据移动指令和寻址模式&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e7%a7%bb%e5%8a%a8%e6%8c%87%e4%bb%a4%e5%92%8c%e5%af%bb%e5%9d%80%e6%a8%a1%e5%bc%8f&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;在 LC-3 中，有七种数据移动指令：&#xA;LD、LDR、LDI、LEA、ST、STR、STI&#xA;加载和存储指令的格式：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;操作码（位 [15:12]）&lt;/li&gt;&#xA;&lt;li&gt;目标寄存器或源寄存器（位 [11:9]）&lt;/li&gt;&#xA;&lt;li&gt;地址生成位（位 [8:0]）&lt;/li&gt;&#xA;&lt;li&gt;有四种位解释方式，称为寻址模式：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;PC 相对模式&lt;/li&gt;&#xA;&lt;li&gt;间接模式&lt;/li&gt;&#xA;&lt;li&gt;基址+偏移模式&lt;/li&gt;&#xA;&lt;li&gt;立即数模式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在 MIPS 中，加载和存储指令只有基址+偏移和立即数两种模式&lt;/p&gt;&#xA;&lt;h3 id=&#34;控制流指令&#34;&gt;控制流指令&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%8e%a7%e5%88%b6%e6%b5%81%e6%8c%87%e4%bb%a4&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;条件跳转与无条件跳转&lt;/p&gt;&#xA;&lt;h3 id=&#34;数据类型&#34;&gt;数据类型&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;指令集支持更多数据类型的优势：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;能更好地将高级语言构造映射到硬件&lt;/li&gt;&#xA;&lt;li&gt;硬件能直接操作编程语言中的数据类型 → 更少的指令数量和代码体积&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;例如：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;矩阵操作 vs. 单独的乘法/加法/加载/存储指令&lt;/li&gt;&#xA;&lt;li&gt;图结构操作 vs. 单独的加载/存储/加法/…指令&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;劣势：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;微架构设计者需做更多工作&lt;/li&gt;&#xA;&lt;li&gt;需要实现操作数据类型的指令&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;涉及权衡tradeoff&#34;&gt;涉及权衡tradeoff&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%b6%89%e5%8f%8a%e6%9d%83%e8%a1%a1tradeoff&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;&#xA;&lt;li&gt;硬件复杂性 vs. 软件复杂性&lt;/li&gt;&#xA;&lt;li&gt;简单指令 vs. 复杂指令的延迟&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;figure&gt;&lt;img data-src=&#34;http://localhost:1313/imgs/comp-arch/datatype.png&#34;&#xA;         data-action=&#34;zoom&#34;&#xA;         class=&#34;lazyload&#34;/&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;h2 id=&#34;汇编-编程&#34;&gt;（汇编）编程&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%b1%87%e7%bc%96-%e7%bc%96%e7%a8%8b&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;编程构造&#34;&gt;编程构造&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e7%bc%96%e7%a8%8b%e6%9e%84%e9%80%a0&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;编程需要将一个任务（即一个工作单元）划分为多个更小的工作单元,目标是将工作单元替换为能表示该部分任务的编程构造。&#xA;有三种基本的编程构造：&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;http://localhost:1313/imgs/comp-arch/program-cons.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;顺序构造&#xA;如果任务可分为两个子任务，且一个接一个执行，使用顺序构造&lt;/li&gt;&#xA;&lt;li&gt;条件构造&#xA;如果任务是两个子任务中执行一个（而不是两个都执行），使用条件构造&#xA;任一子任务可以是“无操作”&#xA;执行完正确子任务后，程序继续执行&lt;/li&gt;&#xA;&lt;li&gt;迭代构造&#xA;如果任务是重复执行某个子任务，但前提是某个条件为真，使用迭代构造&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;指令周期&#34;&gt;指令周期&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%8c%87%e4%bb%a4%e5%91%a8%e6%9c%9f&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;指令周期是一个指令被执行时经历的一系列步骤或阶段:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;FETCH（取指）&lt;/li&gt;&#xA;&lt;li&gt;DECODE（译码）&lt;/li&gt;&#xA;&lt;li&gt;EVALUATE ADDRESS（计算地址）&lt;/li&gt;&#xA;&lt;li&gt;FETCH OPERANDS（取操作数）&lt;/li&gt;&#xA;&lt;li&gt;EXECUTE（执行）&lt;/li&gt;&#xA;&lt;li&gt;STORE RESULT（存结果）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;不是所有指令都需要六个阶段:&#xA;LDR 不需要 EXECUTE&#xA;ADD 不需要 EVALUATE ADDRESS&#xA;Intel x86 指令 ADD [eax], edx 是具有六个阶段的指令示例&lt;/p&gt;&#xA;&lt;h3 id=&#34;指令周期的控制单元&#34;&gt;指令周期的控制单元&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%8c%87%e4%bb%a4%e5%91%a8%e6%9c%9f%e7%9a%84%e6%8e%a7%e5%88%b6%e5%8d%95%e5%85%83&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;一个使用真值表构建的自动机&lt;/p&gt;&#xA;&lt;h3 id=&#34;处理指令-步骤&#34;&gt;“处理指令”步骤&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%a4%84%e7%90%86%e6%8c%87%e4%bb%a4-%e6%ad%a5%e9%aa%a4&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;AS = 时钟周期开始时的架构状态（程序员可见）&#xA;AS&amp;rsquo; = 时钟周期结束时的架构状态（程序员可见）&#xA;一个非常基础的指令处理引擎,每条指令在一个时钟周期内执行, 只使用组合逻辑实现指令执行,没有中间、程序员不可见的状态更新。&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;http://localhost:1313/imgs/comp-arch/as2.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;isa-级别抽象视角&#34;&gt;ISA 级别抽象视角&lt;a class=&#34;anchorjs-link&#34; href=&#34;#isa-%e7%ba%a7%e5%88%ab%e6%8a%bd%e8%b1%a1%e8%a7%86%e8%a7%92&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;从 ISA 视角看，指令执行期间 AS 和 AS&amp;rsquo; 之间没有“中间状态”,每条指令一个状态转换。&#xA;它定义了一个抽象的有限状态机，其中：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;状态 = 程序员可见状态&lt;/li&gt;&#xA;&lt;li&gt;下一状态逻辑 = 指令执行后的结果&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;实现-as-到-as-的转化方式&#34;&gt;实现 AS 到 AS&amp;rsquo; 的转化方式&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%ae%9e%e7%8e%b0-as-%e5%88%b0-as-%e7%9a%84%e8%bd%ac%e5%8c%96%e6%96%b9%e5%bc%8f&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;有多种实现：&#xA;我们可以有程序员不可见的状态以优化指令执行速度：每条指令多个状态转换&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;AS -&amp;gt; AS&amp;rsquo;（一个时钟周期内转换）&lt;/li&gt;&#xA;&lt;li&gt;AS -&amp;gt; AS+MS1 -&amp;gt; AS+MS2 -&amp;gt; AS+MS3 -&amp;gt; AS&amp;rsquo;（多个时钟周期）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;微架构基础与设计&#34;&gt;微架构基础与设计&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%be%ae%e6%9e%b6%e6%9e%84%e5%9f%ba%e7%a1%80%e4%b8%8e%e8%ae%be%e8%ae%a1&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;组成&#34;&gt;组成&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e7%bb%84%e6%88%90&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;h4 id=&#34;数据通路-由处理和转换数据信号的硬件组成&#34;&gt;数据通路：由处理和转换数据信号的硬件组成&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e9%80%9a%e8%b7%af-%e7%94%b1%e5%a4%84%e7%90%86%e5%92%8c%e8%bd%ac%e6%8d%a2%e6%95%b0%e6%8d%ae%e4%bf%a1%e5%8f%b7%e7%9a%84%e7%a1%ac%e4%bb%b6%e7%bb%84%e6%88%90&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;功能单元：对数据进行操作&#xA;硬件结构（如导线、多路选择器、解码器、三态缓冲器）：使数据流入功能单元和寄存器&#xA;存储单元：存储数据（如寄存器）&lt;/p&gt;&#xA;&lt;h4 id=&#34;控制逻辑-由决定控制信号的硬件组成-即指定数据通路元素对数据执行什么操作的信号&#34;&gt;控制逻辑：由决定控制信号的硬件组成，即指定数据通路元素对数据执行什么操作的信号&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%8e%a7%e5%88%b6%e9%80%bb%e8%be%91-%e7%94%b1%e5%86%b3%e5%ae%9a%e6%8e%a7%e5%88%b6%e4%bf%a1%e5%8f%b7%e7%9a%84%e7%a1%ac%e4%bb%b6%e7%bb%84%e6%88%90-%e5%8d%b3%e6%8c%87%e5%ae%9a%e6%95%b0%e6%8d%ae%e9%80%9a%e8%b7%af%e5%85%83%e7%b4%a0%e5%af%b9%e6%95%b0%e6%8d%ae%e6%89%a7%e8%a1%8c%e4%bb%80%e4%b9%88%e6%93%8d%e4%bd%9c%e7%9a%84%e4%bf%a1%e5%8f%b7&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;figure&gt;&lt;img data-src=&#34;http://localhost:1313/imgs/comp-arch/lc3-consist.png&#34;&#xA;         data-action=&#34;zoom&#34;&#xA;         class=&#34;lazyload&#34;/&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;h3 id=&#34;单周期机器&#34;&gt;单周期机器&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%8d%95%e5%91%a8%e6%9c%9f%e6%9c%ba%e5%99%a8&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;&#xA;&lt;li&gt;每条指令只需一个时钟周期&lt;/li&gt;&#xA;&lt;li&gt;所有状态更新在指令执行结束时进行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;主要缺点：最慢的指令决定周期时间 → 时钟周期时间长&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;http://localhost:1313/imgs/comp-arch/single-cycle.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;多周期机器&#34;&gt;多周期机器&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%a4%9a%e5%91%a8%e6%9c%9f%e6%9c%ba%e5%99%a8&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;通过在各个阶段添加寄存器保存当前阶段的执行结果，从而能将指令进行拆分。&#xA;一条指令需要多个时钟周期：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;指令取指（IF）&lt;/li&gt;&#xA;&lt;li&gt;指令译码和寄存器操作数取值（ID/RF）&lt;/li&gt;&#xA;&lt;li&gt;执行/计算内存地址（EX/AG）&lt;/li&gt;&#xA;&lt;li&gt;内存操作数取值（MEM）&lt;/li&gt;&#xA;&lt;li&gt;存储/写回结果（WB）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;指令处理被分解为多个周期/阶段, 在指令执行过程中可以更新状态，架构状态在指令执行结束时更新。&#xA;相比单周期的优势：最慢的“阶段”决定周期时间&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;http://localhost:1313/imgs/comp-arch/multi-cycles.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;性能分析&#34;&gt;性能分析&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;CPI: Cycles Per Instruction&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单条指令的执行时间: {CPI} × {时钟周期时间}&lt;/li&gt;&#xA;&lt;li&gt;整个程序的执行时间: 所有指令之和 [{CPI} × {时钟周期时间}], 即{指令数} × {平均 CPI} × {时钟周期时间}&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;单周期微架构性能&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CPI = 1&lt;/li&gt;&#xA;&lt;li&gt;时钟周期时间 = 长&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;多周期微架构性能&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CPI = 每条指令不同&lt;/li&gt;&#xA;&lt;li&gt;时钟周期时间 = 短&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
  </channel>
</rss>
