<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>乱序执行 on EVER BLOG</title>
    <link>https://qisc123.github.io/tags/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C/</link>
    <description>Recent content in 乱序执行 on EVER BLOG</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 08 May 2025 15:12:23 +0800</lastBuildDate>
    <atom:link href="https://qisc123.github.io/tags/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Computer Architecture Part2</title>
      <link>https://qisc123.github.io/posts/2024/12/computer-architecture-part2/</link>
      <pubDate>Thu, 05 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://qisc123.github.io/posts/2024/12/computer-architecture-part2/</guid>
      <description>&lt;h2 id=&#34;流水线-pipeline&#34;&gt;流水线（Pipeline）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%b5%81%e6%b0%b4%e7%ba%bf-pipeline&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;将单条指令拆分成多个阶段执行后，当其执行到后一个阶段时，前一个阶段的硬件处于空闲状态，此时再发射一条指令从而复用硬件，就像工业流水线生产一样。 &lt;br/&gt;&#xA;更多并发 → 更高的指令吞吐量 &lt;br/&gt;&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/pipeline.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;停顿-stall-流水线停止前进的情况&#34;&gt;停顿（Stall）：流水线停止前进的情况&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%81%9c%e9%a1%bf-stall-%e6%b5%81%e6%b0%b4%e7%ba%bf%e5%81%9c%e6%ad%a2%e5%89%8d%e8%bf%9b%e7%9a%84%e6%83%85%e5%86%b5&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;停顿 = 指令等待其源操作数可用 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;停止所有上游阶段 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;清空所有下游阶段 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;禁用 PC 和 IF/ID 锁存器；确保停顿的指令保持在其当前阶段，在停顿指令之后的流水线阶段插入“无效”指令或空操作（称为“气泡”）。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;资源竞争-resource-contention&#34;&gt;资源竞争（Resource contention）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e8%b5%84%e6%ba%90%e7%ab%9e%e4%ba%89-resource-contention&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;当两个流水线阶段中的指令需要使用同一资源时发生 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;消除引起资源竞争的原因,复制资源或增加资源吞吐量 &lt;br/&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分离指令和数据存储器（缓存） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;为内存结构增加多个端口 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;检测资源竞争并暂停一个争用阶段 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;寄存器文件可在同一周期读写：写入发生在周期上半段, 读取发生在周期下半段, 但读/写操作只有半个时钟周期完成。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;指令间的依赖-dependences&#34;&gt;指令间的依赖（Dependences）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%8c%87%e4%bb%a4%e9%97%b4%e7%9a%84%e4%be%9d%e8%b5%96-dependences&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;数据依赖（Data）&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Flow dependence（写后读） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;figure&gt;&lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/raw.png&#34;&#xA;             data-action=&#34;zoom&#34;&#xA;             class=&#34;lazyload&#34;/&gt;&#xA;    &lt;/figure&gt;&#xA; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Anti dependence（读后写） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;figure&gt;&lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/war.png&#34;&#xA;             data-action=&#34;zoom&#34;&#xA;             class=&#34;lazyload&#34;/&gt;&#xA;    &lt;/figure&gt;&#xA; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Output dependence（写后写） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;figure&gt;&lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/waw.png&#34;&#xA;             data-action=&#34;zoom&#34;&#xA;             class=&#34;lazyload&#34;/&gt;&#xA;    &lt;/figure&gt;&#xA; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;解决方案&lt;/p&gt;&#xA;&lt;p&gt;后两种依赖：只需要在最后阶段、按程序顺序写入目标寄存器 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;处理 Flow 依赖的六种基本方法： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;检测并等待寄存器中值可用 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;检测并转发/旁路数据给依赖指令 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;检测并在软件层面消除依赖（无需硬件检测） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;检测并重新排序，使独立指令先执行 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;预测所需值，进行“推测执行”，然后验证 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;使用其他方式（如细粒度多线程），不需检测 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;可以添加一个硬件单元来检测依赖。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;控制依赖（Control）&lt;/p&gt;&#xA;&lt;p&gt;若取出的指令是控制流指令： &lt;br/&gt;&#xA;如何确定下一条 Fetch 的 PC？使用分支预测器。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;长延迟-多周期-操作-long-latency-operations&#34;&gt;长延迟（多周期）操作（Long-latency operations）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e9%95%bf%e5%bb%b6%e8%bf%9f-%e5%a4%9a%e5%91%a8%e6%9c%9f-%e6%93%8d%e4%bd%9c-long-latency-operations&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;由于长延迟指令占用硬件而造成的等待。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;数据转发-data-forwarding&#34;&gt;数据转发（Data Forwarding）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e8%bd%ac%e5%8f%91-data-forwarding&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;一旦结果可用，即将其转发给依赖的指令，从而降低停顿时间。 &lt;br/&gt;&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/data-forwarding.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;异常与中断-exceptions-and-interrupts&#34;&gt;异常与中断（Exceptions and Interrupts）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%bc%82%e5%b8%b8%e4%b8%8e%e4%b8%ad%e6%96%ad-exceptions-and-interrupts&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;程序执行过程中的“非计划”更改或中断: &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;异常（Exceptions）,源自程序内部的执行问题 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;中断（Interrupts）,来自需要处理的外部事件 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;处理异常和中断的共同步骤： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;停止当前程序 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;保存体系结构状态 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;处理异常/中断 → 切换到处理程序 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;（如可能且合理）返回程序执行 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;示例&#34;&gt;示例&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e7%a4%ba%e4%be%8b&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;&#xA;&lt;li&gt;异常：除以零、溢出、未定义操作码、访问保护错误、缺页错误等。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;中断：I/O 设备请求服务（如键盘输入、视频输入）、（周期性）系统定时器超时、电源故障、机器检查等。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;原因&#34;&gt;原因&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%8e%9f%e5%9b%a0&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;ul&gt;&#xA;&lt;li&gt;异常：来自当前运行线程内部 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;中断：来自线程外部 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;处理时机&#34;&gt;处理时机&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%a4%84%e7%90%86%e6%97%b6%e6%9c%ba&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;ul&gt;&#xA;&lt;li&gt;异常：在检测到且为非推测性异常时，立即处理 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;中断：在合适时机处理（除非是高优先级中断，如电源故障、机器检查） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;优先级：进程（异常），依赖情况（中断） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;处理上下文：进程（异常），系统（中断） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;保持精确以处理异常-中断-precise-exceptions-interrupts&#34;&gt;保持精确以处理异常/中断（Precise Exceptions/Interrupts）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e4%bf%9d%e6%8c%81%e7%b2%be%e7%a1%ae%e4%bb%a5%e5%a4%84%e7%90%86%e5%bc%82%e5%b8%b8-%e4%b8%ad%e6%96%ad-precise-exceptions-interrupts&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;保持精准是冯诺依曼架构成功的关键之一，如果不能做到这一点，调试程序将非常困难，对软件开发来说将是一种挑战。 &lt;br/&gt;&#xA;顺序提交指令的结果是保持程序正确和调试程序精准的关键。 &lt;br/&gt;&#xA;当准备处理异常/中断时，体系结构状态应保持一致（精确） &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;所有前面的指令应已完全完成 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;之后的指令不应已完成 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;当检测到最早可提交的指令导致异常时，控制逻辑将： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;确保架构状态精确（寄存器文件、PC、内存） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;清空流水线中所有较新的指令 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;保存 PC 和寄存器（由 ISA 规定） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;重定向取指引擎到相应的异常处理程序 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;保证精确异常&#34;&gt;保证精确异常&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e4%bf%9d%e8%af%81%e7%b2%be%e7%a1%ae%e5%bc%82%e5%b8%b8&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;单周期机器，每条指令保证在一个周期内完成，没有违反程序语义的风险 &lt;br/&gt;&#xA;多周期机器，需要在控制 FSM 中增加特殊状态，引导到异常/中断处理器，仅在精确状态（如取下一条指令之前）切换到处理程序 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;寄存器&lt;/p&gt;&#xA;&lt;p&gt;EPC 寄存器：保存引发异常的 PC &lt;br/&gt;&#xA;Cause 寄存器：保存异常的原因 &lt;br/&gt;&#xA;异常处理程序地址：如0x80000180 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;重排序缓冲区-reorder-buffer-rob&#34;&gt;重排序缓冲区（Reorder Buffer，ROB）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e9%87%8d%e6%8e%92%e5%ba%8f%e7%bc%93%e5%86%b2%e5%8c%ba-reorder-buffer-rob&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;允许指令乱序完成，即提交，但在结果可见前进行排序，当指令被译码时，分配 ROB 中的下一个顺序条目，指令完成时，将结果写入 ROB 条目，当该条目是 ROB 中最老的且没有异常，其结果写入寄存器或内存 &lt;br/&gt;&#xA;ROB 是一个硬件结构，记录所有译码但尚未提交的指令信息 &lt;br/&gt;&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/rob.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/rob2.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;使用 ROB 的寄存器重命名&lt;/p&gt;&#xA;&lt;p&gt;输出和反依赖并非真实依赖, 虽然是同一寄存器名，实际表示无关的值，由于 ISA 中寄存器数量有限，造成了假依赖 &lt;br/&gt;&#xA;解决方案：将寄存器 ID 重命名为其在 ROB 中的条目 ID &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;寄存器 ID → ROB 条目 ID &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;架构寄存器 ID → 物理寄存器 ID &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;使用 ROB ID 表示寄存器，消除假依赖，扩展寄存器数量 &lt;br/&gt;&#xA;寄存器重命名表（又称别名表） &lt;br/&gt;&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/rat.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;使用 ROB 的顺序流水线&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;译码阶段（D）：访问寄存器文件和 ROB，分配 ROB 条目，若可执行则调度到执行单元 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;执行阶段（E）：允许乱序完成 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;完成阶段（R）：将结果写入 ROB &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;退休/提交阶段（W）：检查最老指令是否异常；若无，则写入寄存器文件或内存；否则，清空流水线并跳转异常处理 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;顺序调度/执行，乱序完成，顺序提交 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;figure&gt;&lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/rob3.png&#34;&#xA;             data-action=&#34;zoom&#34;&#xA;             class=&#34;lazyload&#34;/&gt;&#xA;    &lt;/figure&gt;&#xA; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;指令乱序执行-动态调度&#34;&gt;指令乱序执行（动态调度）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%8c%87%e4%bb%a4%e4%b9%b1%e5%ba%8f%e6%89%a7%e8%a1%8c-%e5%8a%a8%e6%80%81%e8%b0%83%e5%ba%a6&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;调度：将指令发送到功能单元的行为 &lt;br/&gt;&#xA;当前的执行模型： &lt;br/&gt;&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/in-order-pipeline.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&#xA;可以看到不同处理单元所需的周期数是完全不同的，如果顺序发射指令可能会造成长时间的停顿。 &lt;br/&gt;&#xA;顺序流水线的问题： &lt;br/&gt;&#xA;未准备好的指令会阻塞其后的指令调度: &lt;br/&gt;&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/in-order-dispatch.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/out-of-order-dispatch.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;实现&#34;&gt;实现&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%ae%9e%e7%8e%b0&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;ol&gt;&#xA;&lt;li&gt;需要将使用某值的指令与生产者关联,使用寄存器重命名：为每个数据值分配一个“标签” &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;需要缓存指令，直到它们准备好执行,在重命名后插入保留站 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;指令需追踪源操作数的就绪状态,当一个值产生时，广播其“标签”,保留站中指令比较其源标签, 若匹配，则源值准备好 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;所有源值准备好时，调度指令到功能单元（FU）, 若多个指令准备好，每个 FU 需选择一个指令 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;figure&gt;&lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/rs.png&#34;&#xA;         data-action=&#34;zoom&#34;&#xA;         class=&#34;lazyload&#34;/&gt;&#xA;&lt;/figure&gt;&#xA; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;寄存器文件-rf-或寄存器别名表-rat&#34;&gt;寄存器文件（RF）或寄存器别名表（RAT）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%af%84%e5%ad%98%e5%99%a8%e6%96%87%e4%bb%b6-rf-%e6%88%96%e5%af%84%e5%ad%98%e5%99%a8%e5%88%ab%e5%90%8d%e8%a1%a8-rat&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;若 Valid 位为 1，表中值正确,否则，Tag 指出正确值的位置,Tag 是值将要被生产时的唯一标识符。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;所有执行单元都拥有保留站&#34;&gt;所有执行单元都拥有保留站&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%89%80%e6%9c%89%e6%89%a7%e8%a1%8c%e5%8d%95%e5%85%83%e9%83%bd%e6%8b%a5%e6%9c%89%e4%bf%9d%e7%95%99%e7%ab%99&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;h4 id=&#34;公共数据总线-cdb&#34;&gt;公共数据总线（CDB）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%85%ac%e5%85%b1%e6%95%b0%e6%8d%ae%e6%80%bb%e7%ba%bf-cdb&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;用于将计算出的值广播到可能需要它们的所有保留站 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;tomasulo-算法&#34;&gt;Tomasulo 算法&lt;a class=&#34;anchorjs-link&#34; href=&#34;#tomasulo-%e7%ae%97%e6%b3%95&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;ul&gt;&#xA;&lt;li&gt;若在重命名前有可用保留站： &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;将指令和重命名的操作数（值/标签）插入保留站 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;若无保留站，指令停顿 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;在保留站中，指令监听 CDB，等待其源操作数的标签 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;当标签匹配时，获取该值并保存在保留站中 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;当两个操作数都准备好后，指令准备调度 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;当指令完成后 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;申请 CDB &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;将带标签的值发送到 CDB（标签广播） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;寄存器文件连接到 CDB &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;寄存器包含表示最新写入者的标签 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;若标签匹配广播的标签，则写入值并设置有效位 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;回收重命名标签 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;系统中不再存在标签副本 → 可释放资源 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
  </channel>
</rss>
