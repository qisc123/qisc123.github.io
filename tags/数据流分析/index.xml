<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据流分析 on EVER BLOG</title>
    <link>http://localhost:1313/tags/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90/</link>
    <description>Recent content in 数据流分析 on EVER BLOG</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 08 May 2025 16:10:45 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Data Flow Analysis</title>
      <link>http://localhost:1313/posts/2024/05/data-flow-analysis/</link>
      <pubDate>Wed, 22 May 2024 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/2024/05/data-flow-analysis/</guid>
      <description>&lt;h2 id=&#34;数据流分析&#34;&gt;数据流分析&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e6%b5%81%e5%88%86%e6%9e%90&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;依托于控制流结构,即以基本块为单位的CFG(control-flow-graph)。本质上是计算每一个变量的数据依赖关系。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;遍历方式&#34;&gt;遍历方式&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e9%81%8d%e5%8e%86%e6%96%b9%e5%bc%8f&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;前向数据流 forward analysis rpo 逆后序 &lt;br/&gt;&#xA;后向数据流 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;迭代数据流分析&#34;&gt;迭代数据流分析&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e8%bf%ad%e4%bb%a3%e6%95%b0%e6%8d%ae%e6%b5%81%e5%88%86%e6%9e%90&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;解方程组 &lt;br/&gt;&#xA;解决CFG中环的问题 &lt;br/&gt;&#xA;通过将节点的相应集合设为最大，即全部集合的并集 &lt;br/&gt;&#xA;通过不断的取交集进行缩小集合最后达到不动点退出迭代 &lt;br/&gt;&#xA;In 代表 进入节点 Out 代表 退出节点 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;支配性&#34;&gt;支配性&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%94%af%e9%85%8d%e6%80%a7&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;在入口节点为b0的流图中，当且仅当节点bi​位于从b0​到节点bj​的所有路径上时，称节点bi​支配​​（dominates）节点bj​，记作bi​ dom bj​。 &lt;br/&gt;&#xA;dom(n) 为支配n的节点集合 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;br/&gt;&#xA;&lt;p&gt;\(\text{DOM}(n) = \{n\} \cup \left( \cap_{m \in \text{preds}(n)} \text{DOM}(m) \right)\) &lt;br/&gt;&#xA;初始值： &lt;br/&gt;&#xA;\(\text{DOM}(n_0) = \{n_0\},\quad \text{DOM}(n) = N,\, \forall n \ne n_0\) &lt;br/&gt;&#xA;其中，N为CFG中所有节点的集合。 &lt;br/&gt;&#xA;完整算法： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;\begin{aligned}&#xA;&amp;amp;\text{DOM}(0) \leftarrow \{0\} \\&#xA;&amp;amp;\text{for } i \leftarrow 1 \text{ to } |N| - 1 \text{ do} \\&#xA;&amp;amp;\quad \text{DOM}(i) \leftarrow N \\&#xA;&amp;amp;\text{changed} \leftarrow \text{true} \\&#xA;&amp;amp;\text{while (changed) do} \\&#xA;&amp;amp;\quad \text{changed} \leftarrow \text{false} \\&#xA;&amp;amp;\quad \text{for } i \leftarrow 1 \text{ to } |N| - 1 \text{ do} \\&#xA;&amp;amp;\qquad \text{temp} \leftarrow \{i\} \cup \left(\cap_{j \in \text{preds}(i)} \text{DOM}(j) \right) \\&#xA;&amp;amp;\qquad \text{if } \text{temp} \ne \text{DOM}(i) \text{ then} \\&#xA;&amp;amp;\qquad\quad \text{DOM}(i) \leftarrow \text{temp} \\&#xA;&amp;amp;\qquad\quad \text{changed} \leftarrow \text{true}&#xA;\end{aligned}&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;衍生定义&lt;/p&gt;&#xA;&lt;p&gt;严格支配： &lt;br/&gt;&#xA;当d！=n时且d dom n ，则d sdom n &lt;br/&gt;&#xA;直接支配： &lt;br/&gt;&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;http://localhost:1313/imgs/optimization/dominator-tree.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&#xA;在支配树（dominator tree）中，对于结点 n 来说，从根节点到结点 n 所在路径上的结点（不包括n）都严格支配结点 n，例如上图中从根节点 1 -&amp;gt; 2 -&amp;gt; 3，其中结点 1 和 结点 2 都严格支配结点 3。该路径上离结点 n 最近的结点叫做结点 n 的 直接支配结点（immediate ），用 IDom(n) 表示，例如上图中 IDom(6) = 2。换句话说，就是在严格支配性的基础上还得是节点n前的最后一个严格支配节点。 &lt;br/&gt;&#xA;支配边界： &lt;br/&gt;&#xA;Y 是 X 的支配边界，当且仅当 X 支配 Y 的一个前驱结点（CFG）同时 X 并不严格支配 Y &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;效率&lt;/p&gt;&#xA;&lt;p&gt;逆后序遍历 后序遍历的反面 优先遍历父节点 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;活动性&#34;&gt;活动性&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%b4%bb%e5%8a%a8%e6%80%a7&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Live variable &lt;br/&gt;&#xA;A variable v is live at point p if there exists a path from p to a use of v along which v is not redefined &lt;br/&gt;&#xA;\(\text{{LiveOut}}(n) = \bigcup_{m \in \text{{succ}}(n)} (\text{{UEVar}}(m) \cup (\text{{LiveOut}}(m) \cap \overline{ \text{{VARKill}}(m)}))\) &lt;br/&gt;&#xA;在m中定义了的变量和没有定义的变量 &lt;br/&gt;&#xA;UEVar(m)在m中向上展开的变量的集合 &lt;br/&gt;&#xA;向上展开：x在m中重新定义之前，使用了x的引用 &lt;br/&gt;&#xA;如果v在m的入口处存活，要么 v在 m中重新定义并且在重新定义前对其引用，要不穿过m在m的后继过程的开始处存活没有在m中重新定义 &lt;br/&gt;&#xA;初始值： &lt;br/&gt;&#xA;\(\text{LiveOut}(n) = \emptyset, \forall n\) &lt;br/&gt;&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;作用&lt;/p&gt;&#xA;&lt;p&gt;查找未初始化的变量 可能查找的结果有误 &lt;br/&gt;&#xA;全局寄存器分配 &lt;br/&gt;&#xA;ssa构建的改进，不活动的变量不需要插入phi函数 &lt;br/&gt;&#xA;无用的store操作 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;可用表达式&#34;&gt;可用表达式&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%8f%af%e7%94%a8%e8%a1%a8%e8%be%be%e5%bc%8f&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;\(\text{AVAILIN}(n) = \bigcap_{m \in \text{preds}(n)} \left( \text{DEExpr}(m) \cup \left( \text{AvailIn}(m) \cap \overline{\text{ExprKill}(m)} \right) \right)\) &lt;br/&gt;&#xA;在n中可用的表达式包含了在m中表达式定义过的和没有定义过的表达式。 &lt;br/&gt;&#xA;每个节点的初始值：\(\text{AVAILIN}(n_0) = \emptyset\) 且 \(\text{AVAILIN}(n) = \{ \text{all expressions} \}, \forall n \neq n_0\) &lt;br/&gt;&#xA;DEExpr(n)代表着第n个块中的向下展开表达式集合。一个表达式e∈DEEXPR(n)当且仅当块n计算了e，并且e的操作数在块n中对e的最后一次计算到块n的结束之间没有被定义。EXPRKILL(n)包含所有被块n中的定义所杀死的表达式。如果一个或多个操作数在块中被重新定义，那么表达式就会被杀死。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;如果一个表达式e在进入块n时可用，那么它在CFG中n的每个前驱块的退出时也可用。正如方程所述，如果一个表达式e在某个块m的退出时可用，那么有两个条件之一成立：要么e在m中向下暴露，要么它在进入m时可用并且在m中没有被杀死。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;作用&lt;/p&gt;&#xA;&lt;p&gt;AVAILIN集合在全局冗余消除中使用，有时被称为全局公共子表达式消除。实现这一效果的最简单方法可能是为每个块计算AVAILIN集合，并将它们用作本地值编号的初始信息。惰性代码移动是一种更强大的冗余消除形式，也使用可用性。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;可达&#34;&gt;可达&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%8f%af%e8%be%be&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;\(\text{Reaches}(n) = \bigcup_{m \in \text{preds}(n)} ( \text{DEDef}(m) \cup (\text{Reaches}(m) \cap \overline{\text{DefKill}(m)}))\) &lt;br/&gt;&#xA;初始值: &lt;br/&gt;&#xA;\(\text{REACHES}(n) = \emptyset, \forall n\) &lt;br/&gt;&#xA;n的入口 &lt;br/&gt;&#xA;在m中操作数定义过 和 没有定义过即穿过m 到可达 &lt;br/&gt;&#xA;看上去和存活分析中的var很像，但是这里还包含了位置信息 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;作用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;可预测&#34;&gt;可预测&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%8f%af%e9%a2%84%e6%b5%8b&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;\(\text{AntOut}(n) = \bigcap_{m \in \text{succ}(n)} (\text{UEExpr}(m) \cup (\text{AntOut}(m) \cap  \overline{\text{ExprKill}(m)}))\) &lt;br/&gt;&#xA;\(\text{AntOut}(n_f) = \emptyset,\  \text{AntOut}(n) = \{ \text{all expressions} \}, \forall n \neq n_f\) &lt;br/&gt;&#xA;在所有n的后继结点中的第一次计算e与n中的最后一次计算e的值相同的表达式集合。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;作用&lt;/p&gt;&#xA;&lt;p&gt;代码移动 1节约时间缓式代码移动 2空间上 减少代码长度 代码提升 code hoisting &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;过程间综述问题&#34;&gt;过程间综述问题&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e8%bf%87%e7%a8%8b%e9%97%b4%e7%bb%bc%e8%bf%b0%e9%97%ae%e9%a2%98&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;可能修改 may modify &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;静态单赋值形式&#34;&gt;静态单赋值形式&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e9%9d%99%e6%80%81%e5%8d%95%e8%b5%8b%e5%80%bc%e5%bd%a2%e5%bc%8f&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;严格支配 &lt;br/&gt;&#xA;支配区域 &lt;br/&gt;&#xA;支配边界 DF(n) 与 Dom(n)反过来 &lt;br/&gt;&#xA;支配者树 &lt;br/&gt;&#xA;汇合点 &lt;br/&gt;&#xA;Critical edge &lt;br/&gt;&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;构建ssa形式&lt;/p&gt;&#xA;&lt;p&gt;先根次序遍历支配者树，重命名变量，插入phi函数 &lt;br/&gt;&#xA;最大最小 半剪枝 剪枝 liveness &lt;br/&gt;&#xA;全局变量 变量在哪些blocks中存在 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;解除ssa形式，SSA Deconstruction&lt;/p&gt;&#xA;&lt;p&gt;去除phi函数 在前驱节点插入赋值 ，评估存活性，插入临时变量 &lt;br/&gt;&#xA;去除变量名下标？ &lt;br/&gt;&#xA;copy folding 造成的问题 &lt;br/&gt;&#xA;?? eac third ver. p491 对phi函数隔离命名空间的一系列操作 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;全局常量传播&lt;/p&gt;&#xA;&lt;p&gt;sscp算法 &lt;br/&gt;&#xA;sccp &lt;br/&gt;&#xA;半格 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;If n is defined by a φ-function, SSCP sets Value(n) to top. &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;if n’s value is not known, SSCP sets Value(n) to top. &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;If n’s value is a known constant ci, SSCP sets Value(n) to ci. &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;If n’s value cannot be known—for example, it is defined by reading a &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;value from external media—SSCP sets Value(n) to ⊥(buttom). &lt;br/&gt;&#xA;If Value(n) is not top, the algorithm adds n to the worklist. &lt;br/&gt;&#xA;有三种值，代表一个变量的三种情况，当前未知，确定为常量，确定为变量。 &lt;br/&gt;&#xA;然后三种值进行meet运算是单向的从top到Constant到bot ，具体规则见书eac p383 &lt;br/&gt;&#xA;首先把常数和变量 即已知的值放入worklist,然后使用def-use,推导计算所有的使用这些量的def,如果与先前初始化的值不同，那么放入worklist,重新计算 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;过程间分析&#34;&gt;过程间分析&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e8%bf%87%e7%a8%8b%e9%97%b4%e5%88%86%e6%9e%90&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;解决两个问题 &lt;br/&gt;&#xA;1.过程调用对单过程优化的影响 &lt;br/&gt;&#xA;构建调用图 处理过程间常量传播 &lt;br/&gt;&#xA;2.维护过程调用固有抽象的开销 &lt;br/&gt;&#xA;过程间常量传播 &lt;br/&gt;&lt;/p&gt;&#xA;</description>
    </item>
  </channel>
</rss>
