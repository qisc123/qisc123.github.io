<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>上下文无关语法 on EVER BLOG</title>
    <link>http://localhost:1313/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E8%AF%AD%E6%B3%95/</link>
    <description>Recent content in 上下文无关语法 on EVER BLOG</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 17 May 2025 16:24:07 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E8%AF%AD%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Context Free Grammar</title>
      <link>http://localhost:1313/posts/2024/05/context-free-grammar/</link>
      <pubDate>Fri, 03 May 2024 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/2024/05/context-free-grammar/</guid>
      <description>&lt;h2 id=&#34;上下文无关文法概述&#34;&gt;上下文无关文法概述&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e4%b8%8a%e4%b8%8b%e6%96%87%e6%97%a0%e5%85%b3%e6%96%87%e6%b3%95%e6%a6%82%e8%bf%b0&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;下面给出一个上下文无关文法的示例，称其为 \(G_{1}\): &lt;br/&gt;&#xA;A \(\rightarrow\) 0A1 &lt;br/&gt;&#xA;A \(\rightarrow \) B &lt;br/&gt;&#xA;B \(\rightarrow\) # &lt;br/&gt;&#xA;一个文法由一组替换规则（substitution rule）组成，替换规则又称为产生式(production)。 &lt;br/&gt;&#xA;每条规则占一行，由一个符号和一个字符串构成，符号和字符串之间用箭头隔开。符号称为变元(variable)，字符串由变元和另一种称为终结符(terminal)的符号组成。 &lt;br/&gt;&#xA;变元常用大写字母表示，终结符类似于输入字符，常用小写字母、数字或特殊符号表示。 &lt;br/&gt;&#xA;一个变元被指定为起始变元(start variable)，通常它出现在第一条规则的左边。在上述示例中，文法G&lt;sub&gt;1&lt;/sub&gt;有3条规则，A和B是变元，其中A是起始变元，0、1和#是终结符。 &lt;br/&gt;&#xA;获取一个字符串的替换序列称为派生(derivation)。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;按照以下方法，能够根据文法生成其所描述的语言的每一个字符串: &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;写下起始变元。它是第一条规则左边的变元，除非另有指定。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;取一个已写下的变元，并找到以该变元开始的规则，把这个变元替换成规则右边的字符串。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;重复步骤2，直到写下的字符串没有变元为止。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;例: 由G1生成字符串000#111的派生过程为: &lt;br/&gt;&#xA;A⇒0A1⇒00A11⇒000A111⇒000B111⇒000#111 &lt;br/&gt;&#xA;这个过程可以用一颗语法分析树形象的表达。 &lt;br/&gt;&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;http://localhost:1313/imgs/context-free-grammar/grammar-tree.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;定义&#34;&gt;定义&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%ae%9a%e4%b9%89&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;上下文无关文法（context-free grammar）是一个4元组 \[(V, \Sigma, R, S)\]，且 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;\(V\) 是一个有穷集合，称为变元集（variables）。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(\Sigma\) 是一个与 \(V\) 不相交的有穷集合，称为终结符集(terminals)。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(R\) 是一个有穷规则集（rules），每条规则由一个变元和一个由变元及终结符组成的 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;字符串构成。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;\( S \in V\) 是起始变元。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;设u，v和w是由变元及终结符构成的字符串，A→w是文法的一条规则，称uAv生成(yield) uvw，记作uAv⇒uwv。 &lt;br/&gt;&#xA;如果u=v，或者存在序列u1，u2，⋯，uk，使得 &lt;br/&gt;&#xA;u⇒ u1 ⇒u2 ⇒&amp;hellip;⇒uk ⇒v &lt;br/&gt;&#xA;其中k≥0，则称u派生v，记作\(u \overset{*}{\Rightarrow}v \)。该文法的语言是 \(\{ w \in \Sigma^* \mid S \overset{*}{\Rightarrow} w \}\)。 &lt;br/&gt;&#xA;在文法G&lt;sub&gt;1&lt;/sub&gt;中，V = {A, B}, Σ = {0, 1, #}, S = A, 而R是上面提到的示例中给出的3条规则。 &lt;br/&gt;&#xA;在描述一个文法时，通常只写出它的规则。出现在规则左边的所有符号都是变元，其余的符号都是终结符，按照惯例，起始变元是第一条规则左边的变元。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;下推自动机dpa&#34;&gt;下推自动机DPA&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e4%b8%8b%e6%8e%a8%e8%87%aa%e5%8a%a8%e6%9c%badpa&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;下推自动机在之前的NFA,DFA的基础上加上了一个栈，以此来存储信息，非确定性下推自动机等价于上下文无关语法。下推自动机与NFA,DFA最大不同在于能够存储之前状态的信息，从而能够进行嵌套的状态转移。 &lt;br/&gt;&#xA;现代编程语言的语法解析器大多使用了确定性下推自动机。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;下推自动机（Pushdown Automaton, PDA）是一个六元组 \( (Q, \Sigma, \Gamma, \delta, q_0, F)\)，其中 \(Q\)、\(\Sigma\)、\(\Gamma\) 和 \(F\) 都是有限集合，具体含义如下： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;\(Q\) 是状态集合， &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(\Sigma\) 是输入字母表， &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(\Gamma\) 是栈字母表， &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(\delta\) 是状态转移函数，其形式为：  &lt;br/&gt;&#xA;\(\delta : Q \times \Sigma_\varepsilon \times \Gamma_\varepsilon \to \mathcal{P}(Q \times \Gamma_\varepsilon)\), 其中 \(\Sigma_\varepsilon\)表示 \(\Sigma \cup \{\varepsilon\}\)，\(\Gamma_\varepsilon\) 表示 \(\Gamma \cup \{\varepsilon\}\)，\(\mathcal{P}\)表示幂集，即：状态转移由当前状态、输入符号（或 ε）、栈顶符号（或 ε）决定，输出为一组可能的（新状态, 栈操作）对。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(q_0 \in Q\) 是初始状态， &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\( F \subseteq Q \) 是接受状态集合 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/div&gt;&#xA;&lt;h3 id=&#34;确定性下推自动机&#34;&gt;确定性下推自动机&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e7%a1%ae%e5%ae%9a%e6%80%a7%e4%b8%8b%e6%8e%a8%e8%87%aa%e5%8a%a8%e6%9c%ba&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;对应于确定型上下文无关语言(DCFL)。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;确定性下推自动机(deterministic pushdown automaton, DPDA),区别在于转移函数。对于每一组输入和栈顶值只有一种转移，但是它保留了 \(\epsilon-move\) 转移。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;\(\delta : Q \times \Sigma \cup \{\varepsilon\} \times \Gamma \cup \{\varepsilon\} \to (Q \times \Gamma \cup \{\varepsilon\}) \cup \{\emptyset\}\) &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;语法分析&#34;&gt;语法分析&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在语法分析（尤其是形式语言理论和自动机理论）中，希腊字母、大写英文字母和小写英文字母通常用于表示不同的语法成分或符号类别。以下是常见的约定及其含义： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;希腊字母（如 α, β, γ, δ）​​​表示符号串（String of Symbols）,通常代表由终结符和非终结符组成的​​任意符号串​​（可能是空串）。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;​大写英文字母（如 A, B, C, S）​​表示非终结符（Non-terminal Symbols）​​,非终结符代表语法中的变量或抽象语法类别，可以进一步展开为其他符号。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;​​小写英文字母（如 a, b, c, x, y）​​表示终结符（Terminal Symbols）​​,终结符是语法中的基本符号，不可再分解，通常对应语言中的实际单词或字符。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;​​其他常见符号​​ &lt;br/&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;​大写字母（如 V,Σ）​​Σ：终结符的集合（Alphabet） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;V 或 N：非终结符的集合 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;V∪Σ：所有符号的集合（文法符号） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;​大写字母 + 下标（如A1​,B 2​）​​用于区分同类非终结符（如 &amp;lt;expr&amp;gt; 1​和 &amp;lt;expr&amp;gt; 2​)。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;first集&#34;&gt;First集&lt;a class=&#34;anchorjs-link&#34; href=&#34;#first%e9%9b%86&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;\begin{equation*}&#xA;\mathrm{FIRST}(\alpha) =&#xA;\{ a \in \Sigma \mid \alpha \overset{*}{\Rightarrow} a \beta \}&#xA;\cup&#xA;\begin{cases}&#xA;\{\varepsilon\}, &amp;amp; \text{ if } \alpha \overset{*}{\Rightarrow} \varepsilon \\&#xA;\emptyset, &amp;amp; \text{else}&#xA;\end{cases}&#xA;\end{equation*}&lt;/p&gt;&#xA;&lt;p&gt;FIRST(α)为α的开始的终结符的集合。 &lt;br/&gt;&#xA;基本算法 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;若\( \alpha \)以终结符a开头，则\( a \in \mathrm{FIRST}(\alpha)\) &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;若 \( \alpha \) 以非终结符 \( A \) 开头，则将 \( \mathrm{FIRST}(A)\) 加入 \( \mathrm{FIRST}(\alpha) \)； &lt;br/&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;若 \( \varepsilon \in \mathrm{FIRST}(A) \)，则继续考察 \( A \) 之后的符号， &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;否则停止。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;若 \( \alpha \) 的所有符号都能推出 \( \varepsilon \)，则 \( \varepsilon \in \mathrm{FIRST}(\alpha) \)。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;follow集&#34;&gt;Follow集&lt;a class=&#34;anchorjs-link&#34; href=&#34;#follow%e9%9b%86&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;\begin{equation*}&#xA;\mathrm{FOLLOW}(A) =&#xA;\{ a \in \Sigma \mid S \overset{*}{\Rightarrow} \alpha A a \beta \}&#xA;\cup&#xA;\begin{cases}&#xA;\{\$\}, &amp;amp; \text{ if } S \overset{*}{\Rightarrow} \gamma A \\&#xA;\emptyset, &amp;amp; \text{else}&#xA;\end{cases}&#xA;\end{equation*}&lt;/p&gt;&#xA;&lt;p&gt;FOLLOW(A)为非终结符A的后跟符号集合。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;若 \( A \) 是开始符号，则将 \(\$ \)（即输入的结束符号）加入 \( \mathrm{FOLLOW}(A) \)。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;若存在产生式 \( B \rightarrow \alpha A \beta \)，则将 \( \mathrm{FIRST}(\beta)  \) 加入 \( \mathrm{FOLLOW}(A) \)。 &lt;br/&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;若\( \varepsilon \in \mathrm{FIRST}(\beta) \)，或 \( B \rightarrow \alpha A \)（即 \( A \) 是末尾符号），则将 \( \mathrm{FOLLOW}(B) \) 加入 \( \mathrm{FOLLOW}(A) \)。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;重复直到各\( \mathrm{FOLLOW} \)集合不再变化为止。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;自顶向下&#34;&gt;自顶向下&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e8%87%aa%e9%a1%b6%e5%90%91%e4%b8%8b&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;递归向下 LL(k) 从左往右， 从语法树的生成来看是最左推导的。k表示向前看k个字符。 &lt;br/&gt;&#xA;和一般的递归算法一样，如果发生错误，则进行回溯。 &lt;br/&gt;&#xA;优化方法为修改文法，使其能做到唯一的推导，此时自然就没有错误率。 &lt;br/&gt;&#xA;需要一张预测分析表，递归调用隐式的进行状态管理。 &lt;br/&gt;&#xA;LL(1)算法： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;\begin{aligned}&#xA;&amp;amp;\text{word} \leftarrow \text{NextWord()} \\&#xA;&amp;amp;\text{push eof onto Stack} \\&#xA;&amp;amp;\text{push the start symbol } S \text{ onto Stack} \\&#xA;&amp;amp;\text{while (true) do} \\&#xA;&amp;amp;\quad \text{focus} \leftarrow \text{top of Stack} \\&#xA;&amp;amp;\quad \text{if (focus = eof and word = eof) then} \\&#xA;&amp;amp;\qquad \text{report success and break from the loop} \\&#xA;&amp;amp;\quad \text{else if (focus} \in T \text{ or focus = eof) then} \\&#xA;&amp;amp;\qquad \text{if (focus matches word) then} \\&#xA;&amp;amp;\qquad\quad \text{pop Stack} \\&#xA;&amp;amp;\qquad\quad \text{word} \leftarrow \text{NextWord()} \\&#xA;&amp;amp;\qquad \text{else report an error looking for the symbol in focus} \\&#xA;&amp;amp;\quad \text{else} \\&#xA;&amp;amp;\qquad \text{// focus is a nonterminal} \\&#xA;&amp;amp;\qquad \text{if Table[focus, word] is } A \rightarrow \beta_1 \beta_2 \ldots \beta_k \text{ then} \\&#xA;&amp;amp;\qquad\quad \text{pop Stack} \\&#xA;&amp;amp;\qquad\quad \text{for } i \leftarrow k \text{ to } 1 \text{ by } -1 \text{ do} \\&#xA;&amp;amp;\qquad\qquad \text{if } \beta_i \ne \varepsilon \text{ then} \\&#xA;&amp;amp;\qquad\qquad\quad \text{push } \beta_i \text{ onto Stack} \\&#xA;&amp;amp;\qquad \text{else report an error expanding focus}&#xA;\end{aligned}&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;h3 id=&#34;自底向上&#34;&gt;自底向上&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e8%87%aa%e5%ba%95%e5%90%91%e4%b8%8a&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;LR(k) 从左往右分析 最右推导 反向的生成语法树,左边终结符从语法树的叶子节点往上归约至根节点，若从时间顺序倒过来看，即自顶向下生成语法树，则是从最右侧的终结符最先生成。 &lt;br/&gt;&#xA;LR(1) LALR(1) SLR(1) LR(0)文法表示的语言，后一个为前一个的子集。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;基本概念&#34;&gt;基本概念&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;在自底向上的分析器（例如表驱动的 LR (1) 分析器）中，关键步骤是找到下一个 handle（句柄）。高效的句柄发现是实现高效自底向上分析的关键。 &lt;br/&gt;&#xA;LR (1) 分析器使用一个句柄识别自动机，这个自动机被编码在两个表中，传统上称为 Action 表和 Goto 表。 &lt;br/&gt;&#xA;使用项集(item set)形式的下推自动机管理状态。 &lt;br/&gt;&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;http://localhost:1313/imgs/context-free-grammar/lr.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&#xA;该自动机使用移入归约管理状态栈，其包含两个组件：1个栈 ， 1个输入缓冲区 ； &lt;br/&gt;&#xA;主要由4 个操作组成： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;移入：将下一个输入 符号 移入 栈顶 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;规约 ：规约是对栈中的语法符号串进行规约，被规约的串右侧位于栈顶，语法分析器确定串左端 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;接收 ：宣布语法分析过程成功完成 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;报错 ：发现语法错误，执行错误恢复程序。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;LR(1)语法分析器的基本骨架： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;\begin{aligned}&#xA;&amp;amp;\text{push } \langle \text{INVALID}, \text{INVALID} \rangle \text{ onto the stack} \\&#xA;&amp;amp;\text{push } \langle \text{start symbol}, s_0 \rangle \text{ onto the stack} \\&#xA;&amp;amp;\text{word} \leftarrow \text{NextWord()} \\&#xA;&amp;amp;\text{while (true) do} \\&#xA;&amp;amp;\quad \text{state} \leftarrow \text{state from pair at top of stack} \\&#xA;&amp;amp;\quad \text{if } \text{Action}[\text{state}, \text{word}] = \text{“reduce } A \to \beta” \text{ then} \\&#xA;&amp;amp;\qquad \text{pop } |\beta| \text{ pairs from the stack} \\&#xA;&amp;amp;\qquad \text{state} \leftarrow \text{state from pair at top of stack} \\&#xA;&amp;amp;\qquad \text{push } \langle A, \text{Goto}[\text{state}, A] \rangle \text{ onto the stack} \\&#xA;&amp;amp;\quad \text{else if } \text{Action}[\text{state}, \text{word}] = \text{“shift } s_i” \text{ then} \\&#xA;&amp;amp;\qquad \text{push } \langle \text{word}, s_i \rangle \text{ onto the stack} \\&#xA;&amp;amp;\qquad \text{word} \leftarrow \text{NextWord()} \\&#xA;&amp;amp;\quad \text{else if } \text{Action}[\text{state}, \text{word}] = \text{“accept” and word = eof then} \\&#xA;&amp;amp;\qquad \text{break} \\&#xA;&amp;amp;\quad \text{else} \\&#xA;&amp;amp;\qquad \text{throw a syntax error} \\&#xA;&amp;amp;\text{report success /* executed the “accept” case */}&#xA;\end{aligned}&lt;/p&gt;&#xA;&lt;p&gt;这个算法解释 Action 表和 Goto 表，以在输入的逆右推导中找到连续的句柄。当它找到一个句柄〈A → β, k〉时，就将当前句型中位置 k 处的 β 归约为 A，也就是对部分构建的语法树的上层边界进行归约。解析器并不显式地构建语法树，而是把语法树上层边界的前缀保存在一个栈中。栈中的每个元素是一个对〈A, s〉，其中 A 是一个文法符号，s 是一个解析状态。状态串联起归约过程，形成整个解析过程。 &lt;br/&gt;&#xA;变量 word 保存了下一个符号的前瞻符号，也就是栈内容之后的第一个单词。 &lt;br/&gt;&#xA;为了找到下一个句柄，LR (1) 解析器将符号不断地移入栈，直到自动机发现句柄的右端就在栈顶。一旦找到句柄 A → β，解析器就执行归约，用 A 替代 β。解析器从栈中弹出 β 中的符号和对应的状态，然后将 A 和它的新状态压入栈中。Action 和 Goto 表将动作（移进和归约）和状态串联起来，以文法驱动的序列找到一个右推导（如果存在的话）。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;h4 id=&#34;构建自动机&#34;&gt;构建自动机&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%9e%84%e5%bb%ba%e8%87%aa%e5%8a%a8%e6%9c%ba&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;项集&lt;/p&gt;&#xA; &lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;在 LR (1) 解析器中，Action 和 Goto 表编码了每一步解析中句柄和潜在句柄的信息。表构造算法使用 LR (1) 项来表示句柄、潜在句柄以及相关的前瞻符号。 &lt;br/&gt;&#xA;LR (1) 项 ：[𝐴→𝛽•𝛾,𝑎] 包含产生式 𝐴→𝛽𝛾，一个指示栈顶位置的占位符 •，以及一个特定的终结符 a 作为前瞻符号。 &lt;br/&gt;&lt;/p&gt;&#xA; &lt;/div&gt;&#xA;&lt;p&gt;表构造算法构建 规范集合 𝐶𝐶={𝐶𝐶0,𝐶𝐶1,𝐶𝐶2,&amp;hellip;,𝐶𝐶𝑛}，其中每个 𝐶𝐶𝑖∈𝐶𝐶 代表解析器的一个有效配置或一个解析状态。 &lt;br/&gt;&#xA;它包含一个或多个LR(1)项，这些项代表了与该解析状态相对应的句柄或潜在句柄。 &lt;br/&gt;&#xA;对于产生式 𝐴→𝛽𝛾A→βγ 和前瞻符号 a，占位符 • 可能有三种不同的位置，每种对应不同的解释。若某个 𝐶𝐶𝑖  中包含该项，则表示解析器已看到的输入与文法中出现 A 后跟 a 是一致的。• 的位置区分了以下三种情况： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;[A→•βγ,a] 表示 A 是有效的，下一个识别的步骤是 β，这一步是发现 A 的一部分。我们称此项为 可能项；它表示对已看到输入的可能完成。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;[A→β•γ,a] 表示解析器已经从状态 [𝐴→•𝛽𝛾,𝑎] 进展到识别了 β。下一步的有效操作是识别 γ。我们称此项为 部分完成项。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;[A→βγ•,a] 表示解析器已经识别了 βγ，且在一个 A 后面跟着 a 的有效上下文中。如果前瞻符号是 a，那么该项是一个句柄，解析器可以将 βγ 归约为 A。我们称此项为 完成项。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;closure and goto&lt;/p&gt;&#xA;&lt;p&gt;为了构造 LR (1) 项的规范集合 CC，解析器生成器从解析器的初始状态开始， &lt;br/&gt;&#xA;即[Goal→•List,eof] &lt;br/&gt;&#xA;并构建一个所有潜在状态转移的模型。该算法将解析器的每个可能配置（或状态）表示为一组 LR (1) 项。 &lt;br/&gt;&#xA;算法对这些 LR (1) 项集执行两个操作：闭包（closure）和转移（transition）。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;闭包函数（closure） 完善一个状态；给定一组核心项，它会将该组隐含的相关 LR (1) 项全部加入集合中。例如，在任何允许 Goal→List 的地方，产生 𝐿𝑖𝑠𝑡 的产生式也是合法的。因此，项 [Goal→•List,eof] 同时隐含了[List→•List Pair,eof] 和 [List→•Pair,eof] 这两个项。闭包操作找到所有此类项并将它们加入当前状态。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;转移函数（goto） 模拟从某状态 𝑠 出发，读取文法符号 𝑥 后的状态转移效果。算法检查状态 𝑠 中的 LR (1) 项，找到所有 “•” 位置紧挨着 𝑥 的项，将 “•” 移动到 𝑥 之后，把新的项放入 goto 返回的新状态集合中。最后，对新状态再执行闭包操作以完成状态。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;为了方便找到起始符号，我们要求文法有唯一的起始符号，且该符号不出现在任何产生式的右侧。在这个括号文法中，该符号是 Goal。 &lt;br/&gt;&lt;/p&gt;&#xA; &lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;closure函数 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;\begin{aligned}&#xA;&amp;amp;\text{closure}(s) \\&#xA;&amp;amp;\text{while } s \text{ is still changing do} \\&#xA;&amp;amp;\quad \text{for each item } [A \to \beta \bullet C \delta, a] \in s \text{ do} \\&#xA;&amp;amp;\qquad \text{lookahead} \leftarrow \delta a \\&#xA;&amp;amp;\qquad \text{for each production } C \to \gamma \in P \text{ do} \\&#xA;&amp;amp;\qquad\quad \text{for each } b \in \text{FIRST}(\text{lookahead}) \text{ do} \\&#xA;&amp;amp;\qquad\qquad s \leftarrow s \cup \{ [C \to \bullet \gamma, b] \} \\&#xA;&amp;amp;\text{return } s&#xA;\end{aligned}&lt;/p&gt;&#xA; &lt;/div&gt;&#xA; &lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;goto函数： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;\begin{aligned}&#xA;&amp;amp;\text{goto}(s, x) \\&#xA;&amp;amp;t \leftarrow \emptyset \\&#xA;&amp;amp;\text{for each item } i \in s \text{ do} \\&#xA;&amp;amp;\quad \text{if } i \text{ is } [\alpha \to \beta \bullet x \delta, a] \text{ then} \\&#xA;&amp;amp;\qquad t \leftarrow t \cup \{[\alpha \to \beta x \bullet \delta, a]\} \\&#xA;&amp;amp;\text{return } \text{closure}(t)&#xA;\end{aligned}&lt;/p&gt;&#xA; &lt;/div&gt;&#xA; &lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;项集构建算法： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;\begin{aligned}&#xA;&amp;amp;CC_0 \leftarrow \emptyset \\&#xA;&amp;amp;\text{for each production of the form } \text{Goal} \to \alpha \text{ do} \\&#xA;&amp;amp;\quad CC_0 \leftarrow CC_0 \cup \{ [ \text{Goal} \to \bullet \alpha, \text{eof} ] \} \\&#xA;&amp;amp;CC_0 \leftarrow \text{closure}(CC_0) \\&#xA;&amp;amp;CC \leftarrow \{ CC_0 \} \\&#xA;&amp;amp;\text{while (new sets are still being added to } CC) \text{ do} \\&#xA;&amp;amp;\quad \text{for each unmarked set } CC_i \in CC \text{ do} \\&#xA;&amp;amp;\qquad \text{mark } CC_i \text{ as processed} \\&#xA;&amp;amp;\qquad \text{for each } x \text{ following a } \bullet \text{ in an item in } CC_i \text{ do} \\&#xA;&amp;amp;\qquad\quad \text{temp} \leftarrow \text{goto}(CC_i, x) \\&#xA;&amp;amp;\qquad\quad \text{if } \text{temp} \notin CC \text{ then} \\&#xA;&amp;amp;\qquad\qquad CC \leftarrow CC \cup \{\text{temp}\} \\&#xA;&amp;amp;\qquad\qquad \text{record transition from } CC_i \text{ to temp on } x&#xA;\end{aligned}&lt;/p&gt;&#xA; &lt;/div&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;语法分析表&#34;&gt;语法分析表&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e8%a1%a8&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;\begin{aligned}&#xA;&amp;amp;CC_0 \leftarrow \emptyset \\&#xA;&amp;amp;\text{for each production of the form } \text{Goal} \to \alpha \text{ do} \\&#xA;&amp;amp;\quad CC_0 \leftarrow CC_0 \cup \{ [\text{Goal} \to \bullet \alpha, \text{eof}] \} \\&#xA;&amp;amp;CC_0 \leftarrow \text{closure}(CC_0) \\&#xA;&amp;amp;CC \leftarrow \{ CC_0 \} \\&#xA;&amp;amp;\text{while (new sets are still being added to } CC) \text{ do} \\&#xA;&amp;amp;\quad \text{for each unmarked set } CC_i \in CC \text{ do} \\&#xA;&amp;amp;\qquad \text{mark } CC_i \text{ as processed} \\&#xA;&amp;amp;\qquad \text{for each } x \text{ following a } \bullet \text{ in an item in } CC_i \text{ do} \\&#xA;&amp;amp;\qquad\quad \text{temp} \leftarrow \text{goto}(CC_i, x) \\&#xA;&amp;amp;\qquad\quad \text{if } \text{temp} \notin CC \text{ then} \\&#xA;&amp;amp;\qquad\qquad CC \leftarrow CC \cup \{ \text{temp} \} \\&#xA;&amp;amp;\qquad\quad \text{record transition from } CC_i \text{ to temp on } x&#xA;\end{aligned}&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;</description>
    </item>
  </channel>
</rss>
