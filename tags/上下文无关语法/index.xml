<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>上下文无关语法 on EVER BLOG</title>
    <link>http://localhost:1313/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E8%AF%AD%E6%B3%95/</link>
    <description>Recent content in 上下文无关语法 on EVER BLOG</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 08 May 2025 16:03:39 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E8%AF%AD%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Context Free Grammar</title>
      <link>http://localhost:1313/posts/2024/05/context-free-grammar/</link>
      <pubDate>Fri, 03 May 2024 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/2024/05/context-free-grammar/</guid>
      <description>&lt;h2 id=&#34;上下文无关文法概述&#34;&gt;上下文无关文法概述&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e4%b8%8a%e4%b8%8b%e6%96%87%e6%97%a0%e5%85%b3%e6%96%87%e6%b3%95%e6%a6%82%e8%bf%b0&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;下面给出一个上下文无关文法的示例，称其为 \(G_{1}\): &lt;br/&gt;&#xA;A \(\rightarrow\) 0A1 &lt;br/&gt;&#xA;A \(\rightarrow \) B &lt;br/&gt;&#xA;B \(\rightarrow\) # &lt;br/&gt;&#xA;一个文法由一组替换规则（substitution rule）组成，替换规则又称为产生式(production)。 &lt;br/&gt;&#xA;每条规则占一行，由一个符号和一个字符串构成，符号和字符串之间用箭头隔开。符号称为变元(variable)，字符串由变元和另一种称为终结符(terminal)的符号组成。 &lt;br/&gt;&#xA;变元常用大写字母表示，终结符类似于输入字符，常用小写字母、数字或特殊符号表示。 &lt;br/&gt;&#xA;一个变元被指定为起始变元(start variable)，通常它出现在第一条规则的左边。在上述示例中，文法G&lt;sub&gt;1&lt;/sub&gt;有3条规则，A和B是变元，其中A是起始变元，0、1和#是终结符。 &lt;br/&gt;&#xA;获取一个字符串的替换序列称为派生(derivation)。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;按照以下方法，能够根据文法生成其所描述的语言的每一个字符串: &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;写下起始变元。它是第一条规则左边的变元，除非另有指定。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;取一个已写下的变元，并找到以该变元开始的规则，把这个变元替换成规则右边的字符串。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;重复步骤2，直到写下的字符串没有变元为止。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;例: 由G1生成字符串000#111的派生过程为: &lt;br/&gt;&#xA;A⇒0A1⇒00A11⇒000A111⇒000B111⇒000#111 &lt;br/&gt;&#xA;这个过程可以用一颗语法分析树形象的表达。 &lt;br/&gt;&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;http://localhost:1313/imgs/context-free-grammar/grammar-tree.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;定义&#34;&gt;定义&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%ae%9a%e4%b9%89&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;上下文无关文法（context-free grammar）是一个4元组 \[(V, \Sigma, R, S)\]，且 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;\(V\) 是一个有穷集合，称为变元集（variables）。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(\Sigma\) 是一个与 \(V\) 不相交的有穷集合，称为终结符集(terminals)。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(R\) 是一个有穷规则集（rules），每条规则由一个变元和一个由变元及终结符组成的 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;字符串构成。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;\( S \in V\) 是起始变元。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;设u，v和w是由变元及终结符构成的字符串，A→w是文法的一条规则，称uAv生成(yield) uvw，记作uAv⇒uwv。 &lt;br/&gt;&#xA;如果u=v，或者存在序列u1，u2，⋯，uk，使得 &lt;br/&gt;&#xA;u⇒ u1 ⇒u2 ⇒&amp;hellip;⇒uk ⇒v &lt;br/&gt;&#xA;其中k≥0，则称u派生v，记作\(u \Rightarrow^*v \)。该文法的语言是 \(\{ w \in \Sigma^* \mid S \Rightarrow^* w \}\)。 &lt;br/&gt;&#xA;在文法G&lt;sub&gt;1&lt;/sub&gt;中，V = {A, B}, Σ = {0, 1, #}, S = A, 而R是上面提到的示例中给出的3条规则。 &lt;br/&gt;&#xA;在描述一个文法时，通常只写出它的规则。出现在规则左边的所有符号都是变元，其余的符号都是终结符，按照惯例，起始变元是第一条规则左边的变元。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;下推自动机dpa&#34;&gt;下推自动机DPA&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e4%b8%8b%e6%8e%a8%e8%87%aa%e5%8a%a8%e6%9c%badpa&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;下推自动机在之前的NFA,DFA的基础上加上了一个栈，以此来存储信息，非确定性下推自动机等价于上下文无关语法。下推自动机与NFA,DFA最大不同在于能够存储之前状态的信息，从而能够进行嵌套的状态转移。 &lt;br/&gt;&#xA;现代编程语言的语法解析器大多使用了确定性下推自动机。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;下推自动机（Pushdown Automaton, PDA）是一个六元组 \( (Q, \Sigma, \Gamma, \delta, q_0, F)\)，其中 \(Q\)、\(\Sigma\)、\(\Gamma\) 和 \(F\) 都是有限集合，具体含义如下： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;\(Q\) 是状态集合， &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(\Sigma\) 是输入字母表， &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(\Gamma\) 是栈字母表， &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(\delta\) 是状态转移函数，其形式为：  &lt;br/&gt;&#xA;\(\delta : Q \times \Sigma_\varepsilon \times \Gamma_\varepsilon \to \mathcal{P}(Q \times \Gamma_\varepsilon)\), 其中 \(\Sigma_\varepsilon\)表示 \(\Sigma \cup \{\varepsilon\}\)，\(\Gamma_\varepsilon\) 表示 \(\Gamma \cup \{\varepsilon\}\)，\(\mathcal{P}\)表示幂集，即：状态转移由当前状态、输入符号（或 ε）、栈顶符号（或 ε）决定，输出为一组可能的（新状态, 栈操作）对。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(q_0 \in Q\) 是初始状态， &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\( F \subseteq Q \) 是接受状态集合 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/div&gt;&#xA;&lt;h3 id=&#34;确定性下推自动机&#34;&gt;确定性下推自动机&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e7%a1%ae%e5%ae%9a%e6%80%a7%e4%b8%8b%e6%8e%a8%e8%87%aa%e5%8a%a8%e6%9c%ba&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;对应于确定型上下文无关语言(DCFL)。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;确定性下推自动机(deterministic pushdown automaton, DPDA),区别在于转移函数。对于每一组输入和栈顶值只有一种转移，但是它保留了 \(\epsilon-move\) 转移。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;\(\delta : Q \times \Sigma \cup \{\varepsilon\} \times \Gamma \cup \{\varepsilon\} \to (Q \times \Gamma \cup \{\varepsilon\}) \cup \{\emptyset\}\) &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;语法分析&#34;&gt;语法分析&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在语法分析（尤其是形式语言理论和自动机理论）中，希腊字母、大写英文字母和小写英文字母通常用于表示不同的语法成分或符号类别。以下是常见的约定及其含义： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;希腊字母（如 α, β, γ, δ）​​​表示符号串（String of Symbols）,通常代表由终结符和非终结符组成的​​任意符号串​​（可能是空串）。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;​大写英文字母（如 A, B, C, S）​​表示非终结符（Non-terminal Symbols）​​,非终结符代表语法中的变量或抽象语法类别，可以进一步展开为其他符号。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;​​小写英文字母（如 a, b, c, x, y）​​表示终结符（Terminal Symbols）​​,终结符是语法中的基本符号，不可再分解，通常对应语言中的实际单词或字符。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;​​其他常见符号​​ &lt;br/&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;​大写字母（如 V,Σ）​​Σ：终结符的集合（Alphabet） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;V 或 N：非终结符的集合 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;V∪Σ：所有符号的集合（文法符号） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;​大写字母 + 下标（如A1​,B 2​）​​用于区分同类非终结符（如 &amp;lt;expr&amp;gt; 1​和 &amp;lt;expr&amp;gt; 2​)。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;first集&#34;&gt;First集&lt;a class=&#34;anchorjs-link&#34; href=&#34;#first%e9%9b%86&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;FIRST(α)为α的开始的终结符的集合。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;follow集&#34;&gt;Follow集&lt;a class=&#34;anchorjs-link&#34; href=&#34;#follow%e9%9b%86&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;FOLLOW(A)为非终结符A的后跟符号集合。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;自顶向下&#34;&gt;自顶向下&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e8%87%aa%e9%a1%b6%e5%90%91%e4%b8%8b&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;递归向下 LL(k) 从左往右， 从语法树的生成来看是最左推导的。k表示向前看k个字符。 &lt;br/&gt;&#xA;和一般的递归算法一样，如果发生错误，则进行回溯。 &lt;br/&gt;&#xA;优化方法为修改文法，使其能做到唯一的推导，此时自然就没有错误率。 &lt;br/&gt;&#xA;只需要一张预测分析表，递归调用隐式的进行状态管理。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;自底向上&#34;&gt;自底向上&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e8%87%aa%e5%ba%95%e5%90%91%e4%b8%8a&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;移入归约 &lt;br/&gt;&#xA;LR(k) 从左往右分析 最右推导 反向的生成语法树,左边终结符从语法树的叶子节点往上归约至根节点，若从时间顺序倒过来看，即自顶向下生成语法树，则是从最右侧的终结符最先生成。 &lt;br/&gt;&#xA;lr(1) LALR(1) SLR(1) LR(0)文法表示的语言，后一个为前一个的子集。 &lt;br/&gt;&#xA;使用项集(item set)形式的下推自动机管理状态。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;点状规则&#34;&gt;点状规则&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e7%82%b9%e7%8a%b6%e8%a7%84%e5%88%99&#34;&gt;&lt;/a&gt;&lt;/h3&gt;</description>
    </item>
  </channel>
</rss>
