<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>标签2 on EVER BLOG</title>
    <link>http://localhost:1313/tags/%E6%A0%87%E7%AD%BE2/</link>
    <description>Recent content in 标签2 on EVER BLOG</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 16 Apr 2025 23:44:58 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E6%A0%87%E7%AD%BE2/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Llvm Backend</title>
      <link>http://localhost:1313/posts/2024/04/llvm-backend/</link>
      <pubDate>Wed, 24 Apr 2024 20:29:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/2024/04/llvm-backend/</guid>
      <description>&lt;h2 id=&#34;后端&#34;&gt;后端&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%90%8e%e7%ab%af&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;概述&#34;&gt;概述&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%a6%82%e8%bf%b0&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;figure&gt;&lt;img data-src=&#34;http://localhost:1313/imgs/llvm-backend.png&#34;&#xA;         data-action=&#34;zoom&#34;&#xA;         class=&#34;lazyload&#34;/&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;将LLVM IR转换为目标汇编代码需要经历若干步骤。IR被变换为后端友好的指令、函数、全局变量的表示。这种表示随着程序经历各种后端阶段而变化，越来越接近实际的目标指令。上图给出了必需的步骤的概观，从LLVM IR到目标代码或者汇编。&#xA;白色框：非必需的优化Pass以进一步改进翻译的质量。&#xA;浅灰色的中间框：它们在内部也称为super pass，因为它们由若干小的Pass实现。它们和白色框的区别在于，前者这些Pass对后端的成功很关键，而后者对于提高所生成的代码的效率更重要。&lt;/p&gt;&#xA;&lt;h4 id=&#34;指令选择-instructionselection&#34;&gt;指令选择（InstructionSelection）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%8c%87%e4%bb%a4%e9%80%89%e6%8b%a9-instructionselection&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;过程将内存中的IR表示变换为目标特定的SelectionDAG节点。起初，这个过程将三地址结构的LLVM IR变换为DAG（Directed Acyclic Graph）形式，这是有向无环图。每个DAG能够表示单一基本块的计算，这意味着每个基本块关联不同的DAG。典型地节点表示指令，而边编码了它们之间的数据流依赖，但不限于此。转换为DAG是重要的，这让LLVM代码生成程序库能够运用基于树的模式匹配指令选择算法，它经过一些调整，也能工作在DAG上（而不仅仅是树）。到这个过程结束时，DAG已将它所有的LLVM IR节点变换为目标机器节点，这些节点表示机器指令而不是LLVM指令。&lt;/p&gt;&#xA;&lt;p&gt;指令选择之后，对于使用哪些目标指令执行每个基本块的计算，我们已经有了清楚的概念。这编码在SelectionDAG类中。然而，我们需要返回三地址表示形式，以决定基本块内部的指令顺序，因为DAG并不暗示互不依赖的指令之间的顺序。&lt;/p&gt;&#xA;&lt;h4 id=&#34;第1次指令调度-instruction-scheduling&#34;&gt;第1次指令调度（Instruction Scheduling）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e7%ac%ac1%e6%ac%a1%e6%8c%87%e4%bb%a4%e8%b0%83%e5%ba%a6-instruction-scheduling&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;也称为前寄存器分配（RA）调度，对指令排序，同时尝试发现尽可能多的指令层次的并行。然后这些指令被变换为MachineInstr三地址表示。&#xA;回想一下，LLVM IR的寄存器集是无限的。这个性质一直保持着，直到寄存器分配（Register Allocation）&#xA;它将无限的虚拟寄存器的引用转换为有限的目标特定的寄存器集，寄存器不够时挤出（spill）到内存。&lt;/p&gt;&#xA;&lt;h4 id=&#34;第2次指令调度&#34;&gt;第2次指令调度&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e7%ac%ac2%e6%ac%a1%e6%8c%87%e4%bb%a4%e8%b0%83%e5%ba%a6&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;也称为后寄存器分配（RA）调度，在此时发生。因为此时在这个点可获得真实的寄存器信息，某些类型寄存器存在额外的风险和延迟，它们可被用以改进指令顺序。&lt;/p&gt;&#xA;&lt;h4 id=&#34;代码输出-code-emission&#34;&gt;代码输出（Code Emission）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e4%bb%a3%e7%a0%81%e8%be%93%e5%87%ba-code-emission&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;阶段将指令从MachineInstr表示变换为MCInst实例。这种新的表示更适合汇编器和链接器，它有两种选择：输出汇编代码或者输出二进制块（blob）到一种特定的目标代码格式。如此，整个后端流水线用到了四种不同层次的指令表示：内存中的LLVM IR，SelectionDAG节点，MachineInstr，和MCInst。&lt;/p&gt;&#xA;&lt;h3 id=&#34;llc-后端工具&#34;&gt;llc 后端工具&lt;a class=&#34;anchorjs-link&#34; href=&#34;#llc-%e5%90%8e%e7%ab%af%e5%b7%a5%e5%85%b7&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;llc的工作 生成汇编或可执行代码&lt;/p&gt;&#xA;&lt;h4 id=&#34;ir具有目标相关性&#34;&gt;IR具有目标相关性&lt;a class=&#34;anchorjs-link&#34; href=&#34;#ir%e5%85%b7%e6%9c%89%e7%9b%ae%e6%a0%87%e7%9b%b8%e5%85%b3%e6%80%a7&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;在第5章（LLVM中间表示）中，我们解释了IR具有目标相关的一面，尽管它是为所有后端设计的共同语言。因为C/C++语言具有目标相关的属性，所以这种相关性会体现在LLVM IR中。&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;一个例子。&lt;/p&gt;&#xA;&lt;p&gt;考虑你的程序分配了char指针的一个vector，用以存储不同的字符串，你用通用的C语句malloc(sizeof(char*)*n)来为字符串vector分配内存。如果你在前端时指定了目标，比如32位MIPS架构，它生成的代码会让malloc分配n x 4字节的内存，因为在32位MIPS上每个指针是4字节。然而，如果你用llc编译这个bitcode而强制指定x86_64架构，它将生成坏的程序。在运行时，会发生潜在的分段错误（segmentation fault），因为x86_64架构的每个指针是8字节，这使得malloc分配的内存不足够。在x86_64上正确的malloc调用将分配n x 8字节。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;后端代码结构&#34;&gt;后端代码结构&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%90%8e%e7%ab%af%e4%bb%a3%e7%a0%81%e7%bb%93%e6%9e%84&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;代码生成背后的主要程序库位于lib目录和它的子文件夹CodeGen、MC、TableGen、和Target中：&lt;/p&gt;&#xA;&lt;p&gt;CodeGen目录包含的文件和头文件实现了所有通用的代码生成算法：指令选择，指令调度，寄存器分配，和所有它们需要的分析。&lt;/p&gt;&#xA;&lt;p&gt;MC目录实现了低层次功能，包括汇编器（汇编解析器）、松弛算法（反汇编器）、和特定的目标文件格式如ELF、COFF、Macho等等。&lt;/p&gt;&#xA;&lt;p&gt;TableGen目录包含TableGen工具的完整实现，它可以根据.td文件中的高层次的目标描述生成C++代码。&lt;/p&gt;&#xA;&lt;p&gt;每个目标的实现在Target的子文件夹中，如Target/Mips，包括若干.cpp、.h、和.td文件。为不同目标实现类似功能的文件倾向于共用类似的名字。&lt;/p&gt;&#xA;</description>
    </item>
  </channel>
</rss>
