<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>自动机 on EVER BLOG</title>
    <link>http://localhost:1313/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/</link>
    <description>Recent content in 自动机 on EVER BLOG</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 08 May 2025 15:33:58 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Finite Automata</title>
      <link>http://localhost:1313/posts/2024/04/finite-automata/</link>
      <pubDate>Sat, 20 Apr 2024 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/2024/04/finite-automata/</guid>
      <description>&lt;h2 id=&#34;dfa&#34;&gt;DFA&lt;a class=&#34;anchorjs-link&#34; href=&#34;#dfa&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;一台有穷自动机有若干部分: &lt;br/&gt;&#xA;一个状态集和根据输入符号从一个状态到另一个状态的规则。 &lt;br/&gt;&#xA;一个输入字母表，指明所有允许的输入符号。 &lt;br/&gt;&#xA;一个起始状态和一个接受状态集。 &lt;br/&gt;&#xA;形式化定义把一台有穷自动机描述成一张含以下5部分的表：状态集、输入字母表、动作规则、起始状态以及接受状态集。用数学语言表达，5个元素的表经常称为5元组。因此，定义有穷自动机是由这5部分组成的5元组。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;用转移函数（transition function）定义动作规则，常记作δ。如果有穷自动机有从状态x到状态y标有输入符号1的箭头，这表示当它处于状态x时读到1，则转移到状态y。可以用转移函数讲清楚这件事，记作δ(x，1)=y。这个记号是一种数学简写方式。把这些结合在一起得到有穷自动机的形式化定义。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;定义&#34;&gt;定义&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%ae%9a%e4%b9%89&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;&lt;strong&gt;(DFA)&lt;/strong&gt; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;*确定性有穷状态自动机*（Deterministic finite automata，DFA）是一个五元组： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;\[M = (Q, \Sigma, \delta, q_0, F)\] &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;\(Q\)：状态（state）的非空有穷集合 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(\Sigma\)：输入字母表（input alphabet） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(\delta\)：状态转移函数（transition function） &lt;br/&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;\(\delta : Q \times \Sigma \rightarrow Q\) &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(\delta(q, a) = p\) 表示 \(M\) 在状态 \(q\) 下读入字符 \(a\)，则将状态转移到 \(p\) 并将读头指向下一字符串 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;\(q_0\)：开始状态（initial state），\(q_0 \in Q\) &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(F\)：终止状态（final state）或接受状态（accept state），\(F \subseteq Q\) &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;nfa&#34;&gt;NFA&lt;a class=&#34;anchorjs-link&#34; href=&#34;#nfa&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;与DFA的最大区别是对于一个输入，NFA有多个转移。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;定义&#34;&gt;定义&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%ae%9a%e4%b9%89&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;&lt;strong&gt;(NFA)&lt;/strong&gt; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;*非确定性有穷状态自动机*（non-deterministic finite automaton，NFA） &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;\[M =(Q, \Sigma, \delta, q_0, F)\] &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;\(Q, \Sigma, q_0, F\) 的意义与 DFA 相同 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(\delta: Q \times \Sigma \rightarrow 2^Q\) &lt;br/&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;\(\delta(q, a) = \{p_1, p_2, \cdots p_m\} | p_i \subseteq Q\) 表示 \(M\) 在状态 \(q\) 下读入字符 \(a\)，可以将状态转移到 \(p_i\) 并指向下一个字符 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;varepsilon-nfa&#34;&gt;\(\varepsilon\)-NFA&lt;a class=&#34;anchorjs-link&#34; href=&#34;#varepsilon-nfa&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;即带有空转移的NFA。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;定义&#34;&gt;定义&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%ae%9a%e4%b9%89&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;&lt;strong&gt;(\(\varepsilon\)-NFA)&lt;/strong&gt; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;*带空转移的非确定性有穷状态自动机*（non-deterministic finite automaton with \(\varepsilon\) moves，\(\varepsilon\)-NFA） &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;\[M =(Q, \Sigma, \delta, q_0, F)\] &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;\(Q, \Sigma, q_0, F\) 的意义与 DFA 相同 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(\delta: Q \times (\Sigma \cup \{ \varepsilon \}) \rightarrow 2^Q\) &lt;br/&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于 \(\delta(q, s) = \{p_1, p_2, \cdots p_m\}\) 表示 \(M\) 在状态 \(q\) 下读入字符 \(a\)，则可以将状态转移到 \(p_i\) 并将读头指向下一个字符 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;对于 \(\delta(q, \varepsilon) = \{p_1, p_2, \cdots p_m\}\) 表示 \(M\) 在状态 \(q\) 下不读入字符，并将状态转移到 \(p_i\) &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;正则表达式&#34;&gt;正则表达式&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;假设有一个字母表 \(\Sigma\)，正则表达式描述了 $Σ$字符（外加表示空串的特殊字符\(\varepsilon\)）构成的字符串集合。由正则表达式定义的字符串集合称为一个语言，记作\(L( r)\)（其中 \(r\) 为某个正则表达式）。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;正则表达式由以下三种基本运算构成： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Alternation：或操作，记作\(r \mid s\)，其语言为\(\{ x \mid x \in L( r) \lor x \in L(s) \}\)。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Concatenation：并操作，记作 \(rs\)，即\(\{ xy \mid x \in L( r) \land y \in L(s) \}\)。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Closure：\(r\) 的柯林闭包（Kleene closure），记作 \(r^*\)，定义为\(\bigcup\limits_{i=0}^{\infty} r^i\)。 \(L(r^*)\) 包含由 \(L( r)\) 中的字符串通过零次或多次连接构成的所有字符串。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;正则语言与-fa&#34;&gt;正则语言与 FA&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%ad%a3%e5%88%99%e8%af%ad%e8%a8%80%e4%b8%8e-fa&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;rl-与-fa-等价&#34;&gt;RL 与 FA 等价&lt;a class=&#34;anchorjs-link&#34; href=&#34;#rl-%e4%b8%8e-fa-%e7%ad%89%e4%bb%b7&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;div class=&#34;theorem&#34;&gt;&#xA;&lt;p&gt;RL 与 FA 等价。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;proof&#34;&gt;&#xA;&lt;p&gt;只要证明 RL \(\subseteq\) FA，且 FA \(\subseteq\) RL 即可。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;首先证明 FA 能够接受 RL。需要对于任意 RL，要构造一个与之等价的 FA。对于正则文法 \(G = (V, T, P, S)\)，构造 \(M = (V \cup \{Z\}, T, \delta, S, \{Z\})\)，其中 \(\delta\) 的定义如下： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;\[\delta(A, a) =&#xA;\begin{cases}&#xA;\{B | A \rightarrow aB \in P\} \cup \{Z\}, &amp;amp; A \rightarrow a \in P \\&#xA;\{B | A \rightarrow aB \in P\} , &amp;amp; A \rightarrow a \notin P&#xA;\end{cases}\] &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;下面证明 \(L(M) = L(G)\)。设 \(a_1 a_2 \dots a_n \in L(G)\)，即有推导 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;\begin{aligned}&#xA;&amp;amp; S \xRightarrow{+} a_1 a_2 \dots a_n \\&#xA;\Leftrightarrow&amp;amp; S \Rightarrow a_1 A_1 \Rightarrow a_1 a_2 A_2 \Rightarrow \dots \Rightarrow a_1 a_2 \dots a_n&#xA;\end{aligned}&lt;/p&gt;&#xA;&lt;p&gt;因此 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;\begin{aligned}&#xA;&amp;amp; S \rightarrow a_1 A_1 \in P \\&#xA;&amp;amp; A_1 \rightarrow a_2 A_2 \in P \\&#xA;&amp;amp; \dots \\&#xA;&amp;amp; A_{n-2} \rightarrow a_{n-1} A_{n-1} \in P \\&#xA;&amp;amp; A_{n-1} \rightarrow a_n \in P&#xA;\end{aligned}&lt;/p&gt;&#xA;&lt;p&gt;根据此文法，对于 \(\delta\) 有 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;\begin{aligned}&#xA;&amp;amp; A_1 \in \delta(S, a_1) \\&#xA;&amp;amp; A_2 \in \delta(A_1, a_2) \\&#xA;&amp;amp; \dots \\&#xA;&amp;amp; A_{n-1} \in \delta(A_{n-2}, a_{n-1}) \\&#xA;&amp;amp; Z \in \delta(A_{n-1}, a_n)&#xA;\end{aligned}&lt;/p&gt;&#xA;&lt;p&gt;因此 \(Z \in \delta(S, a_1 a_2 \dots a_n)\)，成立。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;这里需要特殊处理 \(\varepsilon\) 的情况。不妨假设 \(S\) 不出现在任何产生式的右部。设 \(S \rightarrow \varepsilon \in P\)，则定义转移 \(\delta(S, \varepsilon) = \{Z\}\)，由于 \(S\) 不出现在产生式的右部，因此 FA 上的转移无法回到 \(S\)，即这个转移不会对其他句子的接受产生影响。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;下面证明 FA 接受的句子都是 RL。由于三种 FA 等价，因此这里只需要证明 DFA 接受的句子是 RL。设 DFA \(M = (Q, \Sigma, \delta, q_0, F)\)，构造 \(G = (Q, \Sigma, P, q_0)\)，其中 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;\[P = \{ q \rightarrow a p | \delta(q, a) = p \} \cup \{q \rightarrow a | \delta(q, a) = p \in F \}\] &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;证明类似。同样这里需要考虑 \(\varepsilon\) 相关的句子。假设 \(q_0 \notin F\)，则 \(\varepsilon \notin L(M)\)，不影响。如果 \(q_0 \in F\)，由于空句子存在与否不影响语言性质，因此存在正则文法 \(G&amp;rsquo;\) 使得 \(L(G&amp;rsquo;) = L(G) \cup \{\varepsilon\} = L(M)\)。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;综上，命题成立。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;从正则表达式到dfa&#34;&gt;从正则表达式到DFA&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e4%bb%8e%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e5%88%b0dfa&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;figure&gt;&lt;img data-src=&#34;http://localhost:1313/imgs/automata/transform.png&#34;&#xA;         data-action=&#34;zoom&#34;&#xA;         class=&#34;lazyload&#34;/&gt;&#xA;&lt;/figure&gt;&#xA; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用Thompson构造法，从RE构造出一个NFA &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;http://localhost:1313/imgs/automata/re2NFA.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&#xA;由Thompson构造法生成的NFA具有一些特定的性质，这些性质简化了其实现过程。每个NFA都有一个开始状态和一个接受状态。 &lt;br/&gt;&#xA;除了初始转换外，没有任何转换会进入开始状态；也没有任何转换会从接受状态离开。 &lt;br/&gt;&#xA;最后，每个状态最多有两个ε转换的进入和两个ε转换的离开，并且在字母表中的某个符号上，最多只有一个进入和一个离开转换。所有这些性质共同简化了NFA的表示和操作。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用子集构造法将NFA转化为DFA &lt;br/&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;FollowEpsilon(n)表示从n出发经过一个或多个\(\varepsilon\)转换所能到达的状态集合加上n。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;Delta(q,c) q为一个集合，初始值为q0,返回q中所有元素应用对应状态转移函数所能到达状态的集合。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;核心思想是尽可能的将NFA中的状态集对应到DFA中的单个状态。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;算法主体是数据流分析中十分常用的不动点迭代，不停的减小问题规模，直到集合为空。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;\begin{array}{l}&#xA;q_0 \gets \text{FollowEpsilon}(\{n_0\}) \\&#xA;Q \gets q_0 \\&#xA;\text{WorkList} \gets \{ q_0 \} \\&#xA;\textbf{while } \text{WorkList} \neq \emptyset \text{ do} \\&#xA;\quad \text{remove } q \text{ from WorkList} \\&#xA;\quad \textbf{for each character } c \in \Sigma \text{ do} \\&#xA;\quad\quad \text{temp} \gets \text{FollowEpsilon}(Delta(q, c)) \\&#xA;\quad\quad \textbf{if } \text{temp} \neq \emptyset \text{ then} \\&#xA;\quad\quad\quad \textbf{if } \text{temp} \notin Q \text{ then} \\&#xA;\quad\quad\quad\quad \text{add temp to both } Q \text{ and WorkList} \\&#xA;\quad\quad\quad \textbf{end if} \\&#xA;\quad\quad\quad T[q, c] \gets \text{temp} \\&#xA;\quad\quad \textbf{end if} \\&#xA;\quad \textbf{end for} \\&#xA;\textbf{end while}&#xA;\end{array}&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;最小化DFA &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;关键在于检测DFA中的两个状态是否相等，如果这两个状态对于所有的输入a,都有同样的行为，那么这两个状态相等，可以合并。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;\begin{array}{l}&#xA;\text{Partition} \leftarrow \{ D - D_A \} \\&#xA;\text{Worklist} \leftarrow \{  D - D_A \} \\&#xA;\textbf{while } \text{Worklist} \neq \emptyset \textbf{ do} \\&#xA;\quad \text{select a set } s \text{ from Worklist and remove it} \\&#xA;\quad \textbf{for each character } c \in \Sigma \textbf{ do} \\&#xA;\quad\quad \text{Image} \leftarrow \{ x \mid \delta(x, c) \in s \} \\&#xA;\quad\quad \textbf{for each set } q \in \text{Partition that has a state in Image do} \\&#xA;\quad\quad\quad q_1 \leftarrow q \cap \text{Image} \\&#xA;\quad\quad\quad q_2 \leftarrow q - q_1 \\&#xA;\quad\quad\quad \textbf{if } q_2 \neq \emptyset \textbf{ then} \\&#xA;\quad\quad\quad\quad \text{remove } q \text{ from Partition} \\&#xA;\quad\quad\quad\quad \text{Partition} \leftarrow \text{Partition} \cup \{ q_1, q_2 \} \\&#xA;\quad\quad\quad\quad \textbf{if } q \in \text{Worklist then} \\&#xA;\quad\quad\quad\quad\quad \text{remove } q \text{ from Worklist} \\&#xA;\quad\quad\quad\quad\quad \text{Worklist} \leftarrow \text{Worklist} \cup \{ q_1, q_2 \} \\&#xA;\quad\quad\quad\quad \textbf{else if } |q_1| \leq |q_2| \textbf{ then} \\&#xA;\quad\quad\quad\quad\quad \text{Worklist} \leftarrow \text{Worklist} \cup \{ q_1 \} \\&#xA;\quad\quad\quad\quad \textbf{else} \\&#xA;\quad\quad\quad\quad\quad \text{Worklist} \leftarrow \text{Worklist} \cup \{ q_2 \} \\&#xA;\quad\quad\quad\quad \textbf{if } s = q \textbf{ then break} \\&#xA;\end{array}&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
  </channel>
</rss>
