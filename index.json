[{"date":"17 May, 2025","subtitle":"\u003ch2 id=\"后端\"\u003e后端\u003ca class=\"anchorjs-link\" href=\"#%e5%90%8e%e7%ab%af\"\u003e\u003c/a\u003e\u003c/h2\u003e\u003ch3 id=\"概述\"\u003e概述\u003ca class=\"anchorjs-link\" href=\"#%e6%a6%82%e8%bf%b0\"\u003e\u003c/a\u003e\u003c/h3\u003e\u003cfigure\u003e\u003cimg data-src=\"/imgs/llvm-backend.png\"\n         data-action=\"zoom\"\n         class=\"lazyload\"/\u003e\n\u003c/figure\u003e\n\n\u003cp\u003e将LLVM IR转换为目标汇编代码需要经历若干步骤。IR被变换为后端友好的指令、函数、全局变量的表示。这种表示随着程序经历各种后端阶段而变化，越来越接近实际的目标指令。上图给出了必需的步骤的概观，从LLVM IR到目标代码或者汇编。\n白色框：非必需的优化Pass以进一步改进翻译的质量。\n浅灰色的中间框：它们在内部也称为super pass，因为它们由若干小的Pass实现。它们和白色框的区别在于，前者这些Pass对后端的成功很关键，而后者对于提高所生成的代码的效率更重要。\u003c/p\u003e","tags":"backend LLVM","title":"LLVM Backend","url":"/posts/2024/06/llvm-backend/"},{"date":"10 January, 2025","subtitle":"\u003ch2 id=\"function\"\u003eFunction\u003ca class=\"anchorjs-link\" href=\"#function\"\u003e\u003c/a\u003e\u003c/h2\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-llvm\" data-lang=\"llvm\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003edefine\u003c/span\u003e \u003cspan class=\"k\"\u003ei32\u003c/span\u003e \u003cspan class=\"vg\"\u003e@sum\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003ei32\u003c/span\u003e \u003cspan class=\"nv\"\u003e%a\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003ei32\u003c/span\u003e \u003cspan class=\"nv\"\u003e%b\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"vg\"\u003e#0\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nl\"\u003eentry:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"nv\"\u003e%add\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003eadd\u003c/span\u003e \u003cspan class=\"k\"\u003ensw\u003c/span\u003e \u003cspan class=\"k\"\u003ei32\u003c/span\u003e \u003cspan class=\"nv\"\u003e%b\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nv\"\u003e%a\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003eret\u003c/span\u003e \u003cspan class=\"k\"\u003ei32\u003c/span\u003e \u003cspan class=\"nv\"\u003e%add\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这个函数返回一个i32类型的值，有两个i32参数，%a和%b.函数声明中的标签#0映射到一组函数属性，这也非常类似于C/C++的函数和方法所用的属性。nsw标记指定这个加法操作是“no signed wrap”的，表示该操作是已知不会溢出的，允许作某些优化。在文件的末尾定义了一组属性： \u003cbr/\u003e\u003c/p\u003e","tags":"llvm-ir","title":"LLVM IR Part2","url":"/posts/2025/01/llvm-ir-part2/"},{"date":"8 January, 2025","subtitle":"\u003ch2 id=\"overview\"\u003eOverview\u003ca class=\"anchorjs-link\" href=\"#overview\"\u003e\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eLLVM中间表示（IR）是连接前端和后端的中枢，让LLVM能够解析多种源语言，为多种目标生成代码。前端产生IR，而后端接收IR。IR也是大部分LLVM目标无关的优化发生的地方。 \u003cbr/\u003e\n它采用静态单赋值（SSA）形式。注意没有一个值是被重复赋值的；每个值只有单一赋值定义了它。每次使用一个值，可以立刻向后追溯到给出其定义的唯一的指令。这可以极大地简化优化，因为SSA形式建立了平凡的use-def链，也就是一个值到达使用之处的定义的列表。如果LLVM不采用SSA形式，我们将需要单独运行一次数据流分析，以计算use-def链，对于经典的优化，这是必不可少的，例如常量传播和公共子表达式消除。 \u003cbr/\u003e\n以三地址指令组织代码。数据处理指令有两个源操作数，和目标操作数以存放结果。它有无限数量的寄存器。注意LLVM局部值可以命名为任意以%符号开头的名字，包括从0开始的数字，例如%0，%1，等等，不限制不同的值的最大数量。 \u003cbr/\u003e\u003c/p\u003e","tags":"llvm-ir","title":"LLVM-IR Part1","url":"/posts/2025/01/llvm-ir-part1/"},{"date":"5 December, 2024","subtitle":"\u003ch2 id=\"流水线-pipeline\"\u003e流水线（Pipeline）\u003ca class=\"anchorjs-link\" href=\"#%e6%b5%81%e6%b0%b4%e7%ba%bf-pipeline\"\u003e\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e将单条指令拆分成多个阶段执行后，当其执行到后一个阶段时，前一个阶段的硬件处于空闲状态，此时再发射一条指令从而复用硬件，就像工业流水线生产一样。 \u003cbr/\u003e\n更多并发 → 更高的指令吞吐量 \u003cbr/\u003e\n\u003cfigure\u003e\n  \u003ca class=\"paragraph-image\"\u003e\n    \u003cimg data-src=\"/imgs/comp-arch/pipeline.png\" data-action=\"zoom\" alt=\"\"  class=\"lazyload\"\u003e\n  \u003c/a\u003e\n  \n\u003c/figure\u003e \u003cbr/\u003e\u003c/p\u003e\n\u003ch3 id=\"停顿-stall-流水线停止前进的情况\"\u003e停顿（Stall）：流水线停止前进的情况\u003ca class=\"anchorjs-link\" href=\"#%e5%81%9c%e9%a1%bf-stall-%e6%b5%81%e6%b0%b4%e7%ba%bf%e5%81%9c%e6%ad%a2%e5%89%8d%e8%bf%9b%e7%9a%84%e6%83%85%e5%86%b5\"\u003e\u003c/a\u003e\u003c/h3\u003e\u003cp\u003e停顿 = 指令等待其源操作数可用 \u003cbr/\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e停止所有上游阶段 \u003cbr/\u003e\u003c/li\u003e\n\u003cli\u003e清空所有下游阶段 \u003cbr/\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e禁用 PC 和 IF/ID 锁存器；确保停顿的指令保持在其当前阶段，在停顿指令之后的流水线阶段插入“无效”指令或空操作（称为“气泡”）。 \u003cbr/\u003e\u003c/p\u003e","tags":"计算机体系结构 乱序执行","title":"Computer Architecture Part2","url":"/posts/2024/12/computer-architecture-part2/"},{"date":"15 November, 2024","subtitle":"\u003ch2 id=\"一种基本计算机模型\"\u003e一种基本计算机模型\u003ca class=\"anchorjs-link\" href=\"#%e4%b8%80%e7%a7%8d%e5%9f%ba%e6%9c%ac%e8%ae%a1%e7%ae%97%e6%9c%ba%e6%a8%a1%e5%9e%8b\"\u003e\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e冯·诺依曼模型\n存储程序\n顺序指令处理\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e内存（存储程序和数据）\u003c/li\u003e\n\u003cli\u003e处理单元\u003c/li\u003e\n\u003cli\u003e输入\u003c/li\u003e\n\u003cli\u003e输出\u003c/li\u003e\n\u003cli\u003e控制单元（控制指令执行的顺序）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cfigure\u003e\n  \u003ca class=\"paragraph-image\"\u003e\n    \u003cimg data-src=\"/imgs/comp-arch/von-neumann.png\" data-action=\"zoom\" alt=\"\"  class=\"lazyload\"\u003e\n  \u003c/a\u003e\n  \n\u003c/figure\u003e \u003cfigure\u003e\n  \u003ca class=\"paragraph-image\"\u003e\n    \u003cimg data-src=\"/imgs/comp-arch/lc3.png\" data-action=\"zoom\" alt=\"\"  class=\"lazyload\"\u003e\n  \u003c/a\u003e\n  \n\u003c/figure\u003e\u003c/p\u003e\n\u003ch2 id=\"指令集\"\u003e指令集\u003ca class=\"anchorjs-link\" href=\"#%e6%8c%87%e4%bb%a4%e9%9b%86\"\u003e\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eISA 是软件指令与硬件执行之间的接口\nISA指定了：\u003c/p\u003e","tags":"计算机体系结构","title":"Computer Architecture Part1","url":"/posts/2024/11/computer-architecture-part1/"},{"date":"22 May, 2024","subtitle":"\u003ch2 id=\"数据流分析\"\u003e数据流分析\u003ca class=\"anchorjs-link\" href=\"#%e6%95%b0%e6%8d%ae%e6%b5%81%e5%88%86%e6%9e%90\"\u003e\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e依托于控制流结构,即以基本块为单位的CFG(control-flow-graph)。本质上是计算每一个变量的数据依赖关系。 \u003cbr/\u003e\u003c/p\u003e\n\u003ch3 id=\"遍历方式\"\u003e遍历方式\u003ca class=\"anchorjs-link\" href=\"#%e9%81%8d%e5%8e%86%e6%96%b9%e5%bc%8f\"\u003e\u003c/a\u003e\u003c/h3\u003e\u003cp\u003e前向数据流 forward analysis rpo 逆后序 \u003cbr/\u003e\n后向数据流 \u003cbr/\u003e\u003c/p\u003e\n\u003ch3 id=\"迭代数据流分析\"\u003e迭代数据流分析\u003ca class=\"anchorjs-link\" href=\"#%e8%bf%ad%e4%bb%a3%e6%95%b0%e6%8d%ae%e6%b5%81%e5%88%86%e6%9e%90\"\u003e\u003c/a\u003e\u003c/h3\u003e\u003cp\u003e解方程组 \u003cbr/\u003e\n解决CFG中环的问题 \u003cbr/\u003e\n通过将节点的相应集合设为最大，即全部集合的并集 \u003cbr/\u003e\n通过不断的取交集进行缩小集合最后达到不动点退出迭代 \u003cbr/\u003e\nIn 代表 进入节点 Out 代表 退出节点 \u003cbr/\u003e\u003c/p\u003e","tags":"数据流分析","title":"Data Flow Analysis","url":"/posts/2024/05/data-flow-analysis/"},{"date":"3 May, 2024","subtitle":"\u003ch2 id=\"上下文无关文法概述\"\u003e上下文无关文法概述\u003ca class=\"anchorjs-link\" href=\"#%e4%b8%8a%e4%b8%8b%e6%96%87%e6%97%a0%e5%85%b3%e6%96%87%e6%b3%95%e6%a6%82%e8%bf%b0\"\u003e\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e下面给出一个上下文无关文法的示例，称其为 \\(G_{1}\\): \u003cbr/\u003e\nA \\(\\rightarrow\\) 0A1 \u003cbr/\u003e\nA \\(\\rightarrow \\) B \u003cbr/\u003e\nB \\(\\rightarrow\\) # \u003cbr/\u003e\n一个文法由一组替换规则（substitution rule）组成，替换规则又称为产生式(production)。 \u003cbr/\u003e\n每条规则占一行，由一个符号和一个字符串构成，符号和字符串之间用箭头隔开。符号称为变元(variable)，字符串由变元和另一种称为终结符(terminal)的符号组成。 \u003cbr/\u003e\n变元常用大写字母表示，终结符类似于输入字符，常用小写字母、数字或特殊符号表示。 \u003cbr/\u003e\n一个变元被指定为起始变元(start variable)，通常它出现在第一条规则的左边。在上述示例中，文法G\u003csub\u003e1\u003c/sub\u003e有3条规则，A和B是变元，其中A是起始变元，0、1和#是终结符。 \u003cbr/\u003e\n获取一个字符串的替换序列称为派生(derivation)。 \u003cbr/\u003e\u003c/p\u003e","tags":"词法分析 上下文无关语法","title":"Context Free Grammar","url":"/posts/2024/05/context-free-grammar/"},{"date":"24 April, 2024","subtitle":"\u003ch2 id=\"后端\"\u003e后端\u003ca class=\"anchorjs-link\" href=\"#%e5%90%8e%e7%ab%af\"\u003e\u003c/a\u003e\u003c/h2\u003e\u003ch3 id=\"概述\"\u003e概述\u003ca class=\"anchorjs-link\" href=\"#%e6%a6%82%e8%bf%b0\"\u003e\u003c/a\u003e\u003c/h3\u003e\u003cfigure\u003e\u003cimg data-src=\"/imgs/llvm-backend.png\"\n         data-action=\"zoom\"\n         class=\"lazyload\"/\u003e\n\u003c/figure\u003e\n\n\u003cp\u003e将LLVM IR转换为目标汇编代码需要经历若干步骤。IR被变换为后端友好的指令、函数、全局变量的表示。这种表示随着程序经历各种后端阶段而变化，越来越接近实际的目标指令。上图给出了必需的步骤的概观，从LLVM IR到目标代码或者汇编。\n白色框：非必需的优化Pass以进一步改进翻译的质量。\n浅灰色的中间框：它们在内部也称为super pass，因为它们由若干小的Pass实现。它们和白色框的区别在于，前者这些Pass对后端的成功很关键，而后者对于提高所生成的代码的效率更重要。\u003c/p\u003e","tags":"标签1 标签2","title":"Llvm Backend","url":"/posts/2024/04/llvm-backend/"},{"date":"20 April, 2024","subtitle":"\u003ch2 id=\"dfa\"\u003eDFA\u003ca class=\"anchorjs-link\" href=\"#dfa\"\u003e\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e一台有穷自动机有若干部分: \u003cbr/\u003e\n一个状态集和根据输入符号从一个状态到另一个状态的规则。 \u003cbr/\u003e\n一个输入字母表，指明所有允许的输入符号。 \u003cbr/\u003e\n一个起始状态和一个接受状态集。 \u003cbr/\u003e\n形式化定义把一台有穷自动机描述成一张含以下5部分的表：状态集、输入字母表、动作规则、起始状态以及接受状态集。用数学语言表达，5个元素的表经常称为5元组。因此，定义有穷自动机是由这5部分组成的5元组。 \u003cbr/\u003e\u003c/p\u003e","tags":"自动机 正则表达式","title":"Finite Automata","url":"/posts/2024/04/finite-automata/"}]