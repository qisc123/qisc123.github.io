<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on EVER BLOG</title>
    <link>https://qisc123.github.io/posts/</link>
    <description>Recent content in Posts on EVER BLOG</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 18 May 2025 11:23:56 +0800</lastBuildDate>
    <atom:link href="https://qisc123.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LLVM Backend</title>
      <link>https://qisc123.github.io/posts/2024/06/llvm-backend/</link>
      <pubDate>Sat, 17 May 2025 18:02:35 +0800</pubDate>
      <guid>https://qisc123.github.io/posts/2024/06/llvm-backend/</guid>
      <description>&lt;h2 id=&#34;后端&#34;&gt;后端&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%90%8e%e7%ab%af&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;概述&#34;&gt;概述&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%a6%82%e8%bf%b0&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;figure&gt;&lt;img data-src=&#34;https://qisc123.github.io/imgs/llvm-backend.png&#34;&#xA;         data-action=&#34;zoom&#34;&#xA;         class=&#34;lazyload&#34;/&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;将LLVM IR转换为目标汇编代码需要经历若干步骤。IR被变换为后端友好的指令、函数、全局变量的表示。这种表示随着程序经历各种后端阶段而变化，越来越接近实际的目标指令。上图给出了必需的步骤的概观，从LLVM IR到目标代码或者汇编。&#xA;白色框：非必需的优化Pass以进一步改进翻译的质量。&#xA;浅灰色的中间框：它们在内部也称为super pass，因为它们由若干小的Pass实现。它们和白色框的区别在于，前者这些Pass对后端的成功很关键，而后者对于提高所生成的代码的效率更重要。&lt;/p&gt;&#xA;&lt;h4 id=&#34;指令选择-instructionselection&#34;&gt;指令选择（InstructionSelection）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%8c%87%e4%bb%a4%e9%80%89%e6%8b%a9-instructionselection&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;过程将内存中的IR表示变换为目标特定的SelectionDAG节点。起初，这个过程将三地址结构的LLVM IR变换为DAG（Directed Acyclic Graph）形式，这是有向无环图。每个DAG能够表示单一基本块的计算，这意味着每个基本块关联不同的DAG。典型地节点表示指令，而边编码了它们之间的数据流依赖，但不限于此。转换为DAG是重要的，这让LLVM代码生成程序库能够运用基于树的模式匹配指令选择算法，它经过一些调整，也能工作在DAG上（而不仅仅是树）。到这个过程结束时，DAG已将它所有的LLVM IR节点变换为目标机器节点，这些节点表示机器指令而不是LLVM指令。&lt;/p&gt;&#xA;&lt;p&gt;指令选择之后，对于使用哪些目标指令执行每个基本块的计算，我们已经有了清楚的概念。这编码在SelectionDAG类中。然而，我们需要返回三地址表示形式，以决定基本块内部的指令顺序，因为DAG并不暗示互不依赖的指令之间的顺序。&lt;/p&gt;&#xA;&lt;h4 id=&#34;第1次指令调度-instruction-scheduling&#34;&gt;第1次指令调度（Instruction Scheduling）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e7%ac%ac1%e6%ac%a1%e6%8c%87%e4%bb%a4%e8%b0%83%e5%ba%a6-instruction-scheduling&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;也称为前寄存器分配（RA）调度，对指令排序，同时尝试发现尽可能多的指令层次的并行。然后这些指令被变换为MachineInstr三地址表示。&#xA;回想一下，LLVM IR的寄存器集是无限的。这个性质一直保持着，直到寄存器分配（Register Allocation）&#xA;它将无限的虚拟寄存器的引用转换为有限的目标特定的寄存器集，寄存器不够时挤出（spill）到内存。&lt;/p&gt;&#xA;&lt;h4 id=&#34;第2次指令调度&#34;&gt;第2次指令调度&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e7%ac%ac2%e6%ac%a1%e6%8c%87%e4%bb%a4%e8%b0%83%e5%ba%a6&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;也称为后寄存器分配（RA）调度，在此时发生。因为此时在这个点可获得真实的寄存器信息，某些类型寄存器存在额外的风险和延迟，它们可被用以改进指令顺序。&lt;/p&gt;&#xA;&lt;h4 id=&#34;代码输出-code-emission&#34;&gt;代码输出（Code Emission）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e4%bb%a3%e7%a0%81%e8%be%93%e5%87%ba-code-emission&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;阶段将指令从MachineInstr表示变换为MCInst实例。这种新的表示更适合汇编器和链接器，它有两种选择：输出汇编代码或者输出二进制块（blob）到一种特定的目标代码格式。如此，整个后端流水线用到了四种不同层次的指令表示：内存中的LLVM IR，SelectionDAG节点，MachineInstr，和MCInst。&lt;/p&gt;&#xA;&lt;h3 id=&#34;llc-后端工具&#34;&gt;llc 后端工具&lt;a class=&#34;anchorjs-link&#34; href=&#34;#llc-%e5%90%8e%e7%ab%af%e5%b7%a5%e5%85%b7&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;llc的工作 生成汇编或可执行代码&lt;/p&gt;&#xA;&lt;h4 id=&#34;ir具有目标相关性&#34;&gt;IR具有目标相关性&lt;a class=&#34;anchorjs-link&#34; href=&#34;#ir%e5%85%b7%e6%9c%89%e7%9b%ae%e6%a0%87%e7%9b%b8%e5%85%b3%e6%80%a7&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;在第5章（LLVM中间表示）中，我们解释了IR具有目标相关的一面，尽管它是为所有后端设计的共同语言。因为C/C++语言具有目标相关的属性，所以这种相关性会体现在LLVM IR中。&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;一个例子。&lt;/p&gt;&#xA;&lt;p&gt;考虑你的程序分配了char指针的一个vector，用以存储不同的字符串，你用通用的C语句malloc(sizeof(char*)*n)来为字符串vector分配内存。如果你在前端时指定了目标，比如32位MIPS架构，它生成的代码会让malloc分配n x 4字节的内存，因为在32位MIPS上每个指针是4字节。然而，如果你用llc编译这个bitcode而强制指定x86_64架构，它将生成坏的程序。在运行时，会发生潜在的分段错误（segmentation fault），因为x86_64架构的每个指针是8字节，这使得malloc分配的内存不足够。在x86_64上正确的malloc调用将分配n x 8字节。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;后端代码结构&#34;&gt;后端代码结构&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%90%8e%e7%ab%af%e4%bb%a3%e7%a0%81%e7%bb%93%e6%9e%84&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;代码生成背后的主要程序库位于lib目录和它的子文件夹CodeGen、MC、TableGen、和Target中：&#xA;CodeGen目录包含的文件和头文件实现了所有通用的代码生成算法：指令选择，指令调度，寄存器分配，和所有它们需要的分析。&#xA;MC目录实现了低层次功能，包括汇编器（汇编解析器）、松弛算法（反汇编器）、和特定的目标文件格式如ELF、COFF、Macho等等。&#xA;TableGen目录包含TableGen工具的完整实现，它可以根据.td文件中的高层次的目标描述生成C++代码。&#xA;每个目标的实现在Target的子文件夹中，如Target/Mips，包括若干.cpp、.h、和.td文件。为不同目标实现类似功能的文件倾向于共用类似的名字。&lt;/p&gt;&#xA;&lt;h3 id=&#34;指令选择&#34;&gt;指令选择&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%8c%87%e4%bb%a4%e9%80%89%e6%8b%a9&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;h4 id=&#34;概述&#34;&gt;概述&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%a6%82%e8%bf%b0&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;指令选择是将LLVM IR转换为代表目标指令的SelectionDAG节点（SDNode）的过程。第一步是根据LLVM IR指令建立DAG，创建SelectionDAG对象，其节点保存IR操作。接着，这些节点经过低层化、DAG结合、和合法化等过程，使它更容易匹配目标指令。然后，指令选择用节点模式匹配方法执行DAG到DAG的变换，将SelectionDAG节点转换为代表目标指令的节点。&lt;/p&gt;&#xA;&lt;h4 id=&#34;dag图&#34;&gt;DAG图&lt;a class=&#34;anchorjs-link&#34; href=&#34;#dag%e5%9b%be&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;figure&gt;&lt;img data-src=&#34;https://qisc123.github.io/imgs/CFG.png&#34;&#xA;         data-action=&#34;zoom&#34;&#xA;         class=&#34;lazyload&#34;/&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;DAG的连线（edge）通过use-def关系强制它的操作之间的顺序。如果节点B（例如，add）有一条出去的连线到节点A（例如，Constant&amp;lt;-10&amp;gt;），这意味着节点A定义了一个值（32位整数-10），而节点B使用它（作为加法的一个操作数）。因此，A操作必须在B之前执行。&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;黑色箭头&lt;/p&gt;&#xA;&lt;p&gt;表示常规连线，指示数据流依赖，正如例子add。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;虚线蓝色箭头&lt;/p&gt;&#xA;&lt;p&gt;表示非数据流链，用以强制两条指令的顺序，否则它们就是不相关的，例如，load和store指令必须固定它们原始的程序顺序，如果它们访问相同的内存位置。在前面的图中，我们知道CopyToReg操作必须在X86ISD::RET_FLAG之前发生，由于虚线蓝色箭头。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;红色连线&lt;/p&gt;&#xA;&lt;p&gt;保证它相邻的节点必须粘合在一起，这意味着它们必须紧挨着执行，它们之间不可有其它指令。例如，我们指定相同的节点CopyToReg和X86ISD::RET_FLAG必须安排为紧挨着，由于红色的连线。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;每个节点可以提供一个不同的值类型&lt;/p&gt;&#xA;&lt;p&gt;依赖于它和它的使用者的关系。一个值不必是具体的，也可能是一个抽象的标记（token）。它可能有任意如下类型：&lt;/p&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;节点所提供的值可以是一个具体的值类型&lt;/p&gt;&#xA;&lt;p&gt;表示整数、浮点数、向量、或指针。数据处理节点根据它的操作数计算一个新的值，其结果是这种类别的一个例子。类型可以是i32、i64、f32、v2f32（有两个f32元素的向量）、和iPTR等。在LLVM示意图中，当另一个节点使用这个值的时候，生产者-消费者关系是由一条常规的黑色连线描绘的。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Other类型&lt;/p&gt;&#xA;&lt;p&gt;是一个抽象的标记，用于表示链值（示意图中的ch）。在LLVM示意图中，当另一个节点使用一个Other类型的值的时候，连接两者的连线被打印为蓝色的虚线。chain链的缩写&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Glue类型&lt;/p&gt;&#xA;&lt;p&gt;表示粘合。在LLVM示意图中，当另一个节点使用一个Glue类型的值的时候，连接两者的连线被画成红色。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;SelectionDAG&lt;/p&gt;&#xA;&lt;p&gt;基本块入口的EntryToken，Other类型，链的起点。SelectionDAG对象还会引用图的根节点，这个根节点是最后一条指令的后续节点，它们的关系也被编码为Other类型的值的一个链。&#xA;selectiondag 构建 sdnode 创建 结构&lt;/p&gt;&#xA;&lt;p&gt;在这个阶段，目标无关和目标特定的节点可以同时存在，这是执行预备步骤的结果，例如低层化和合法化，这些预备步骤负责为指令选择准备DAG。然而，等到指令选择结束的时候，所有被目标指令匹配的节点都会是目标特定的。&#xA;代码入口 SelectionDAGISel::SelectBasicBlock 构建selectiondag  gdb or lldb进行查看&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;低层化-lowering&#34;&gt;低层化 lowering&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e4%bd%8e%e5%b1%82%e5%8c%96-lowering&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;首先，一个SelectionDAGBuilder实例（详情见SelectionDAGISel.cpp）访问每个函数，为每个基本块创建一个SelectionDAG对象。&#xA;在此过程期间，一些特殊的IR指令例如call和ret已经要求目标特定的语句——例如，如何传递调用参数和如何从一个函数返回——被转换为SelectionDAG节点。&#xA;为了解决这个问题，TargetLowering class中的算法第一次被使用。这个class是每个目标都必须实现的抽象接口，但是还有大量共用的功能被所有后端所使用。&lt;/p&gt;&#xA;&lt;p&gt;为了实现这个抽象接口，每个目标声明一个TargetLowering的子类，命名为&amp;lt;Target&amp;gt;TargetLowering。每个目标还重载方法，它们实现一个具体的目标无关的高层次的节点应该如何被低层化到一个层次，它接近这个机器的节点。如期望那样，仅有小部分节点必须以这种方式低层化，而大部分其它节点在指令选择时被匹配和替换。&#xA;例如，在sum.bc的SelectionDAG中，用X86TargetLowering::LowerReturn()方法（参见lib/Target/X86/X86ISelLowering.cpp）低层化ret IR指令。同时，生成了X86ISD::RET_FLAG节点，它将函数结果复制到EAX——一种处理函数返回的目标特定的方式。&lt;/p&gt;&#xA;&lt;h4 id=&#34;dag结合与合法化&#34;&gt;DAG结合与合法化&lt;a class=&#34;anchorjs-link&#34; href=&#34;#dag%e7%bb%93%e5%90%88%e4%b8%8e%e5%90%88%e6%b3%95%e5%8c%96&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;从SelectionDAGBuilder输出的SelectionDAG并不能直接作指令选择，必须经历附加的转换——如前面图中所显示的。先于指令选择执行的Pass序列如下：&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;DAG结合Pass combine&lt;/p&gt;&#xA;&lt;p&gt;优化欠优化的SelectionDAG结构，通过匹配一系列节点并用简化的结构替换它们，当可获利时。&#xA;例如，子图(add (Register X), (constant 0))可以合并为(RegisterX)。&#xA;类似地，目标特定的结合方法可以识别节点模式，并决定结合合并它们是否将提高此目标的指令选择的质量。&#xA;在lib/CodeGen/SelectionDAG/DAGCombiner.cpp文件中找到LLVM通用的DAG结合的实现。&#xA;在lib/Target/&amp;lt;Target_Name&amp;gt;/&amp;lt;Target&amp;gt;ISelLowering.cpp文件中找到目标特定的结合的实现。&#xA;方法setTargetDAGCombine()标记目标想要结合的节点。举例来说，MIPS后端尝试结合加法——见lib/Target/Mips/MipsISelLowering.cpp中的setTargetDAGCombine(ISD::ADD)和performADDCombine()。&lt;/p&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;时机&lt;/p&gt;&#xA;&lt;p&gt;DAG结合在每次合法化之后运行，以最小化任何SelectionDAG冗余。而且，DAG结合知道在Pass链的何处运行，（例如在类型合法化或者向量合法化之后），能够运用这些信息以变得更精确。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;合法化 legalized&lt;/p&gt;&#xA;&lt;p&gt;对于某些类型，扩展会消除向量而使用标量。这可能引入目标不支持的标量类型。然而，后续的类型合法化会清理这种情况。&lt;/p&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;类型合法化&lt;/p&gt;&#xA;&lt;p&gt;类型合法化Pass确保指令选择只需要处理合法的类型。&#xA;合法的类型是指目标天然地支持的类型。例如，在只支持i32类型的目标上，i64操作数的加法是非法的。在这种情况下，类型合法化动作整数展开把i64操作数破分为两个i32操作数，同时生成合适的节点以操作它们。目标定义了每种类型所关联的寄存器，显式地声明了支持的类型。这样，非法的类型必须被删除并相应地处理：标量类型可以被提升，展开，或者软件化，而向量类型可以被分解，标量化，或者放宽——见llvm/include/llvm/Target/TargetLowering.h对每种情况的解释。此外，目标还可以设置定制的方法来合法化类型。&#xA;类型合法化运行两次，在第一次DAG结合之后和在向量合法化之后。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;向量合法化&lt;/p&gt;&#xA;&lt;p&gt;有的时候，后端直接支持向量类型，这意味着有一个这样的寄存器类，但是没有处理给定向量类型的具体的操作。例如，x86的SSE2支持v4i32向量类型。然而，并没有x86指令支持v4i32类型的ISD::OR操作，而只有v2i64的。因此，向量合法化会处理这种情况，提升或者扩展操作，为指令使用合法的类型。目标还可以通过定制的方式处理合法化。对于前面提到的ISD::OR，操作会被提升而使用v2i64类型。看一看下面的lib/Target/X86/X86ISelLowering.cpp的代码片段：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;DAG合法化&lt;/p&gt;&#xA;&lt;p&gt;扮演向量合法化一样的角色，但是它处理任意剩余的具有不支持的类型（标量或向量）的操作。它支持相同的动作：提升、扩展、和定制节点的处理。举例来说，x86不支持以下三种情形：i8类型的有符号整数到浮点数的转化操作（ISD::SINT_TO_FP），请求合法化提升它；i32操作数的有符号除法（ISD::SDIV），发起一个扩展请求，产生一个库调用以处理这个除法；f32操作数的浮点数绝对值，利用定制的句柄生成具有相同效果的等价的代码。x86以如下方式发起这些动作（参见lib/Target/X86/X86ISelLowering.cpp）：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;dag到dag的指令选择的目的&#34;&gt;DAG到DAG的指令选择的目的&lt;a class=&#34;anchorjs-link&#34; href=&#34;#dag%e5%88%b0dag%e7%9a%84%e6%8c%87%e4%bb%a4%e9%80%89%e6%8b%a9%e7%9a%84%e7%9b%ae%e7%9a%84&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;利用模式匹配将目标无关的节点转换为目标特定的节点。指令选择的算法是局部的，每次作用SelectionDAG（基本块）的实例。&#xA;作为例子，后面给出了指令选择之后我们最终的SelectionDAG结构。CopyToReg、CopyFromReg、和Register节点保持不变，直到寄存器分配。实际上，指令选择过程甚至可能增加节点。指令选择之后，ISD::ADD节点被转换为X86指令ADD32ri8，X86ISD::RET_FLAG变为RET。&#xA;注意，三种指令表示类型可能在同一个DAG中并存：通用的LLVM ISD节点比如ISD::ADD，目标特定的&amp;lt;Target&amp;gt;ISD节点比如X86ISD::REG_FLAG，目标物理指令比如X86::ADD32ri8。&lt;/p&gt;&#xA;&lt;h4 id=&#34;sdnode&#34;&gt;sdnode&lt;a class=&#34;anchorjs-link&#34; href=&#34;#sdnode&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-tablegen&#34; data-lang=&#34;tablegen&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;SDNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;opcode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;SDTypeProfile&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;typeprof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;             &lt;span class=&#34;k&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;SDNodeProperty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;props&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[],&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;sdclass&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;SDNode&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;             &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;SDPatternOperator&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;k&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Opcode&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;opcode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;k&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;SDClass&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;sdclass&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;k&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Properties&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;props&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;nv&#34;&gt;SDTypeProfile&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;TypeProfile&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;typeprof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;sdnodeproperty 中有SDNPHasChain属性，表示指令涉及控制依赖在这个简单的dag(单独块构成)中,用于规定指令的执行顺序，像add之类的指令由于已经有明确的数据流依赖进行规定顺序,&#xA;所以不再需要这个属性。&#xA;在copyto/fromReg指令(用于寄存器分配前的虚拟寄存器)中使用很多&lt;/p&gt;&#xA;&lt;h3 id=&#34;tablegen&#34;&gt;tablegen&lt;a class=&#34;anchorjs-link&#34; href=&#34;#tablegen&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;分为前后端&#xA;具体实现由后端生成&#xA;llvm-tblgen -gen-register-info X86.td -I ../../../include&lt;/p&gt;&#xA;&lt;h4 id=&#34;特别类型&#34;&gt;特别类型&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e7%89%b9%e5%88%ab%e7%b1%bb%e5%9e%8b&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;dag (operator operand1, operand2,…, operandN)&#xA;操作符只能是一个记录实例，操作数 (operand1…operandN) 可以是任意类型&#xA;(可选) 可以将操作符和/或每个操作数与标记相关联，如下所示:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-tablegen&#34; data-lang=&#34;tablegen&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;tmp1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Expression&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;mul&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$op&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&amp;gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;tmp2&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Expression&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;mul&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$op&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&amp;gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Expression&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;plus&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;tmp1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$term1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;tmp2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$term2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;nv&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$term3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&amp;gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;标签总是以美元符号 $ 开头，然后是用户定义的标签名。这些标记提供了每个 DAG 组件的逻&#xA;辑描述。&#xA;只是一个信息聚合，具体实现由后端生成.&lt;/p&gt;&#xA;&lt;h4 id=&#34;一个例子&#34;&gt;一个例子&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e4%b8%80%e4%b8%aa%e4%be%8b%e5%ad%90&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-tablegen&#34; data-lang=&#34;tablegen&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;GR16&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;RegisterClass&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;X86&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;i16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                      &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;add&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;AX&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;CX&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;DX&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;BX&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;BP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;SP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                          &lt;span class=&#34;nv&#34;&gt;R8W&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;R9W&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;R15W&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;R12W&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;R13W&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&amp;gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;RegisterClass在：&#xA;/llvm/include/llvm/target/target.td 许多基类在此目录中&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-tablegen&#34; data-lang=&#34;tablegen&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;RegisterClass&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;ValueType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;regTypes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;alignment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;k&#34;&gt;dag&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;regList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;RegAltNameIndex&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;idx&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;NoRegAltName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;DAGOperand&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Namespace&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c&#34;&gt;// The register size/alignment information, parameterized by a HW mode.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nv&#34;&gt;RegInfoByHwMode&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;RegInfos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c&#34;&gt;// RegType - Specify the list ValueType of the registers in this register&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// class.  Note that all registers in a register class must have the same&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// ValueTypes.  This is a list because some targets permit storing different&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// types in same register, for example vector values with 128-bit total size,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// but different count/size of items, like SSE on x86.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;//&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;ValueType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;RegTypes&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;regTypes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c&#34;&gt;// Size - Specify the spill size in bits of the registers.  A default value of&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// zero lets tablgen pick an appropriate size.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Size&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c&#34;&gt;// Alignment - Specify the alignment required of the registers when they are&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// stored or loaded to memory.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;//&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Alignment&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;alignment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c&#34;&gt;// CopyCost - This value is used to specify the cost of copying a value&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// between two registers in this register class. The default value is one&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// meaning it takes a single instruction to perform the copying. A negative&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// value means copying is extremely expensive or impossible.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;CopyCost&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c&#34;&gt;// MemberList - Specify which registers are in this class.  If the&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// allocation_order_* method are not specified, this also defines the order of&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// allocation used by the register allocator.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;//&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;dag&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;MemberList&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;regList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c&#34;&gt;// AltNameIndex - The alternate register name to use when printing operands&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// of this register class. Every register in the register class must have&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// a valid alternate name for the given index.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nv&#34;&gt;RegAltNameIndex&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;altNameIndex&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c&#34;&gt;// isAllocatable - Specify that the register class can be used for virtual&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// registers and register allocation.  Some register classes are only used to&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// model instruction operand constraints, and should have isAllocatable = 0.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;bit&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;isAllocatable&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c&#34;&gt;// AltOrders - List of alternative allocation orders. The default order is&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// MemberList itself, and that is good enough for most targets since the&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// register allocators automatically remove reserved registers and move&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// callee-saved registers to the end.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;dag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;AltOrders&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[];&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c&#34;&gt;// AltOrderSelect - The body of a function that selects the allocation order&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// to use in a given machine function. The code will be inserted in a&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// function like this:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;//&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;//   static inline unsigned f(const MachineFunction &amp;amp;MF) { ... }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;//&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// The function should return 0 to select the default order defined by&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// MemberList, 1 to select the first AltOrders entry and so on.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;code&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;AltOrderSelect&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;[{}]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c&#34;&gt;// Specify allocation priority for register allocators using a greedy&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// heuristic. Classes with higher priority values are assigned first. This is&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// useful as it is sometimes beneficial to assign registers to highly&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// constrained classes first. The value has to be in the range [0,63].&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;AllocationPriority&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c&#34;&gt;// The diagnostic type to present when referencing this operand in a match&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// failure error message. If this is empty, the default Match_InvalidOperand&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// diagnostic type will be used. If this is &amp;#34;&amp;lt;name&amp;gt;&amp;#34;, a Match_&amp;lt;name&amp;gt; enum&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// value will be generated and used for this operand type. The target&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// assembly parser is responsible for converting this into a user-facing&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// diagnostic message.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;DiagnosticType&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c&#34;&gt;// A diagnostic message to emit when an invalid value is provided for this&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// register class when it is being used an an assembly operand. If this is&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// non-empty, an anonymous diagnostic type enum value will be generated, and&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// the assembly matcher will provide a function to map from diagnostic types&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;// to message strings.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;DiagnosticString&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;// The memberList in a RegisterClass is a dag of set operations. TableGen&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;// evaluates these set operations and expand them into register lists. These&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;// are the most common operation, see test/TableGen/SetTheory.td for more&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;// examples of what is possible:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;//&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;// (add R0, R1, R2) - Set Union. Each argument can be an individual register, a&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;// register class, or a sub-expression. This is also the way to simply list&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;// registers.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;em&gt;llvm/test/TableGen/SetTheory.td&#xA;中有许多dag定义 如（add x,y,&amp;hellip;）&#xA;patterm (set )&#xA;/llvm/include/llvm/codegen&lt;/em&gt;&#xA;cpu0.td  一系列td&lt;/p&gt;&#xA;&lt;p&gt;/include/llvm/target/targetselectionDAG.td&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-tablegen&#34; data-lang=&#34;tablegen&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;PatFrags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;dag&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;ops&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;dag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;frags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;code&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;pred&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;[{}]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;               &lt;span class=&#34;nv&#34;&gt;SDNodeXForm&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;xform&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;NOOP_SDNodeXForm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;SDPatternOperator&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;err&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;include&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;codegen&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;sdnodeproperties&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;td&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;SDPatternOperator&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;k&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;SDNodeProperty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Properties&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[];&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;#+&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;end_&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;#+&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;begin_src&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>LLVM IR Part2</title>
      <link>https://qisc123.github.io/posts/2025/01/llvm-ir-part2/</link>
      <pubDate>Fri, 10 Jan 2025 00:00:00 +0800</pubDate>
      <guid>https://qisc123.github.io/posts/2025/01/llvm-ir-part2/</guid>
      <description>&lt;h2 id=&#34;function&#34;&gt;Function&lt;a class=&#34;anchorjs-link&#34; href=&#34;#function&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-llvm&#34; data-lang=&#34;llvm&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;define&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;vg&#34;&gt;@sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;vg&#34;&gt;#0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nl&#34;&gt;entry:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nv&#34;&gt;%add&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;add&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;nsw&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%a&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%add&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个函数返回一个i32类型的值，有两个i32参数，%a和%b.函数声明中的标签#0映射到一组函数属性，这也非常类似于C/C++的函数和方法所用的属性。nsw标记指定这个加法操作是“no signed wrap”的，表示该操作是已知不会溢出的，允许作某些优化。在文件的末尾定义了一组属性： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-llvm&#34; data-lang=&#34;llvm&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;attributes&lt;/span&gt; &lt;span class=&#34;vg&#34;&gt;#0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;nounwind&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;ssp&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;uwtable&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;disable-tail-calls&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;false&amp;#34;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;less-precise-fpmad&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;false&amp;#34;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;no-frame-pointer-elim&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;no-frame-pointer-elim-non-leaf&amp;#34;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;no-infs-fp-math&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;false&amp;#34;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;no-nans-fp-math&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;false&amp;#34;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;stack-protector-buffer-size&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;8&amp;#34;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;target-cpu&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;core2&amp;#34;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;target-features&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+ssse3&amp;#34;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;unsafe-fp-math&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;false&amp;#34;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;use-soft-float&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;false&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;函数体被显式地划分成基本块（BB: basic block），标签（label）用于开始一个新的基本块。一个标签关联一个基本块，如同一个值的定义关联一条指令。如果一个标签声明遗漏了，LLVM汇编器会自动生成一个，运用它自己的命名方案。基本块是指令的序列，它的第一条指令是其单一入口点，它的最后一条指令是其单一出口点。这样，当代码跳跃到对应一个基本块的标签时，我们知道它将执行这个基本块中的所有指令，直到最后一条指令——这条指令将改变控制流，跳跃到其它的基本块。基本块和它们关联的标签，需要遵从下面的条件： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;每个BB需要以一个终结者指令结束，它跳跃到其它BB或者从函数返回 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;第一个BB，称为入口BB，它在一个LLVM函数中是特殊的，不能作为任何跳转指令的目标 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;构建&#34;&gt;构建&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%9e%84%e5%bb%ba&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;ol&gt;&#xA;&lt;li&gt;获取函数类型 返回类型与参数类型 &lt;br/&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;FunctionType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getFunctionType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Exp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fnExp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;params&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;your_ast&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;returnType&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hasReturnType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;your_ast&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                          &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getTypeFromString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;your_ast&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                          &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getInt32Ty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Parameter types:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;     &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;paramTypes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;param&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;params&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;paramName&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;extractVarName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;param&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;paramTy&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;extractVarType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;param&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;//dependence your ast&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;c1&#34;&gt;// The `self` name is special, meaning instance of a class:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;       &lt;span class=&#34;n&#34;&gt;paramTypes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push_back&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;n&#34;&gt;paramName&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;self&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cls&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getPointerTo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;paramTy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;FunctionType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;returnType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;paramTypes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* varargs */&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&#xA;&lt;li&gt;建立函数原型 &lt;br/&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Function&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Create&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fnType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Function&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ExternalLinkage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fnName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;verifyFunction&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Install in the environment:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;define&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fnName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&#xA;&lt;li&gt;构建entry 基本块 &lt;br/&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;createFunctionBlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Function&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Implement here...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;entry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;createBB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;entry&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SetInsertPoint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;entry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&#xA;&lt;li&gt;保存参数到栈上 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;设置返回值 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;调用函数&#34;&gt;调用函数&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e8%b0%83%e7%94%a8%e5%87%bd%e6%95%b0&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;简单示例 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-llvm&#34; data-lang=&#34;llvm&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;%1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;call&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;vg&#34;&gt;@function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;callable&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;gen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ast&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//llvm::value* 即前面llvm::Function::Create()函数创建的对象&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//  生成可调用对象（函数名或表达式）&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{};&lt;/span&gt;                &lt;span class=&#34;c1&#34;&gt;// 参数列表&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;exp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 遍历剩余参数&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push_back&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;gen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;exp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;// 生成每个参数的LLVM值&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Function&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;callable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;           &lt;span class=&#34;c1&#34;&gt;// 强制转换为函数指针&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CreateCall&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;          &lt;span class=&#34;c1&#34;&gt;// 创建函数调用指令&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;class&#34;&gt;Class&lt;a class=&#34;anchorjs-link&#34; href=&#34;#class&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;构建 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;创建class对应的llvm::StructType* 类型 &lt;br/&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;n&#34;&gt;cls&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;StructType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;create&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&#xA;&lt;li&gt;判断是否有父类 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;创建ClassInfo &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;!--listend--&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ClassInfo&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;StructType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;StructType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fieldsMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Function&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;methodsMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;&#xA;&lt;li&gt;填充ClassInfo和StructType类型 同时生成对应的成员函数 &lt;br/&gt;&#xA;若类型point有一个构造函数名为constructor，在llvm ir中函数名为point_constructor。注：ptr为新版llvm-15以后的opaque ptr mode 后，指针的表示，此时指针类型不再保存类型信息， &lt;br/&gt;&#xA;类型信息全部在alloca、store、load等指令的生成时作为参数传入。可能需要另外的数据结构存放ast中解析变量的类型信息。在llvm-14及之前指针表示为type* 与C一致。 &lt;br/&gt;&#xA;示例： &lt;br/&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-llvm&#34; data-lang=&#34;llvm&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;k&#34;&gt;define&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;vg&#34;&gt;@Point_constructor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;ptr&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;nl&#34;&gt;entry:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nv&#34;&gt;%self1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;alloca&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;align&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;8&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;store&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;ptr&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;ptr&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%self1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;align&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;8&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nv&#34;&gt;%x2&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;alloca&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;align&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;store&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;ptr&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%x2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;align&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nv&#34;&gt;%y3&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;alloca&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;align&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;store&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;ptr&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%y3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;align&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;gep&#34;&gt;GEP&lt;a class=&#34;anchorjs-link&#34; href=&#34;#gep&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;在类型中会用到gep这条llvm-ir指令，下图是其基本格式 &lt;br/&gt;&#xA;&amp;lt;address&amp;gt; = getelementptr &amp;lt;ty&amp;gt;, &amp;lt;ty&amp;gt;* base, idx1, idx2,&amp;hellip; &lt;br/&gt;&#xA;示例：若要取之前结构体的一个变量的地址： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-llvm&#34; data-lang=&#34;llvm&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;%1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;getelementptr&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;inbounds&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%Point&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%Point&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;address&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CreateStructGEP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ptrname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;instance-heap-allcoate&#34;&gt;Instance heap allcoate&lt;a class=&#34;anchorjs-link&#34; href=&#34;#instance-heap-allcoate&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;使用外部函数比如C标准库中的malloc,返回一个指针，具体见其api &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;class-inheritance-vtable&#34;&gt;Class inheritance vtable&lt;a class=&#34;anchorjs-link&#34; href=&#34;#class-inheritance-vtable&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;figure&gt;&lt;img data-src=&#34;https://qisc123.github.io/imgs/vtable.png&#34;&#xA;         data-action=&#34;zoom&#34;&#xA;         class=&#34;lazyload&#34;/&gt;&#xA;&lt;/figure&gt;&#xA; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;若要实现类型系统以及子类型的正确识别，以及多态调用，需要为每个类型创建一个“classname_vtable”的结构体，其中都为llvm::functiontype 类型 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;将结构体放入之前class创建的结构体之中 &lt;br/&gt;&#xA;例子： &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--listend--&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-llvm&#34; data-lang=&#34;llvm&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;%Point_vTable&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;%Point&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;*)*,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;%Point&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;*,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)*&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;%Point&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%Point_vTable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;*,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;buildVTable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;StructType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;className&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cls&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vTableName&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;className&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;_vTable&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;c1&#34;&gt;// The vTable should already exist:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vTableTy&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;StructType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getTypeByName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vTableName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Constant&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vTableMethods&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vTableMethodTys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;methodInfo&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;classMap_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;className&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;methodsMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;method&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;methodInfo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;second&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;n&#34;&gt;vTableMethods&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push_back&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;n&#34;&gt;vTableMethodTys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push_back&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;n&#34;&gt;vTableTy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;setBody&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vTableMethodTys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vTableValue&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ConstantStruct&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vTableTy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vTableMethods&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;n&#34;&gt;createGlobalVar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vTableName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vTableValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;functor&#34;&gt;Functor&lt;a class=&#34;anchorjs-link&#34; href=&#34;#functor&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;关键在与为class 创建一个类似构造函数的与类型绑定的独特函数，当以调用函数的方式调用某个class的实例时，调用次方法。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;closure&#34;&gt;Closure&lt;a class=&#34;anchorjs-link&#34; href=&#34;#closure&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/closure.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&#xA;Functor 加 自由变量即堆上变量。将一个堆上变量作为参数,传递给拥有相应处理变量function的类型的构造函数，此类型的functor函数例如取名为_&lt;em&gt;call&lt;/em&gt;_()函数为实际的处理函数。 &lt;br/&gt;&#xA;以lisp举例 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-lisp&#34; data-lang=&#34;lisp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;SetThatType&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;null&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;begin&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;anyType&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;AnyType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;constructor&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;self&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;anyType&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;AnyType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;SetThatType&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;begin&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;set&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;prop&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;self&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;anyType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;anyType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           &lt;span class=&#34;nv&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;__call__&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;self&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;begin&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;set&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;prop&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;prop&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;self&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;anyType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;nv&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))))&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;AnyType&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;anyValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;setN&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;SetThatType&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;//setN&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;此时是一个SetThatType实例&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;setN&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;//functor&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;以调用函数的形式调用类型实例&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;即调用其__call__函数&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>LLVM-IR Part1</title>
      <link>https://qisc123.github.io/posts/2025/01/llvm-ir-part1/</link>
      <pubDate>Wed, 08 Jan 2025 00:00:00 +0800</pubDate>
      <guid>https://qisc123.github.io/posts/2025/01/llvm-ir-part1/</guid>
      <description>&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;a class=&#34;anchorjs-link&#34; href=&#34;#overview&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;LLVM中间表示（IR）是连接前端和后端的中枢，让LLVM能够解析多种源语言，为多种目标生成代码。前端产生IR，而后端接收IR。IR也是大部分LLVM目标无关的优化发生的地方。 &lt;br/&gt;&#xA;它采用静态单赋值（SSA）形式。注意没有一个值是被重复赋值的；每个值只有单一赋值定义了它。每次使用一个值，可以立刻向后追溯到给出其定义的唯一的指令。这可以极大地简化优化，因为SSA形式建立了平凡的use-def链，也就是一个值到达使用之处的定义的列表。如果LLVM不采用SSA形式，我们将需要单独运行一次数据流分析，以计算use-def链，对于经典的优化，这是必不可少的，例如常量传播和公共子表达式消除。 &lt;br/&gt;&#xA;以三地址指令组织代码。数据处理指令有两个源操作数，和目标操作数以存放结果。它有无限数量的寄存器。注意LLVM局部值可以命名为任意以%符号开头的名字，包括从0开始的数字，例如%0，%1，等等，不限制不同的值的最大数量。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;这种IR有三种等价形式： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;驻留内存的表示（指令类等） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;磁盘上的以空间高效方式编码的位表示（bitcode文件） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;磁盘上的人类可读文本表示（LLVM汇编文件） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;figure&gt;&lt;img data-src=&#34;https://qisc123.github.io/imgs/overview.png&#34;&#xA;         data-action=&#34;zoom&#34;&#xA;         class=&#34;lazyload&#34;/&gt;&#xA;&lt;/figure&gt;&#xA; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;figure&gt;&lt;img data-src=&#34;https://qisc123.github.io/imgs/overview2.png&#34;&#xA;         data-action=&#34;zoom&#34;&#xA;         class=&#34;lazyload&#34;/&gt;&#xA;&lt;/figure&gt;&#xA; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;context是module的容器，保存了构建module需要的信息，module是llvm ir的编译单元，使用llvm Builder构建module. &lt;br/&gt;&#xA;整个LLVM文件的内容，无论汇编或者bitcode，定义了一个LLVM模块（module）。模块是LLVM IR的顶层数据结构。每个模块包含一系列函数，每个函数包含一系列基本块，每个基本块包含一系列指令。模块还包含一些外围实体以支持其模型，例如全局变量、目标数据布局、外部函数原型，还有数据结构声明。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;构建module&#34;&gt;构建module&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%9e%84%e5%bb%bamodule&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;ol&gt;&#xA;&lt;li&gt;初始化module &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;设置外部函数 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;设置全局作用域 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;设置目标布局和目标triple &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;!--listend--&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;moduleInit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;setupExternFunctions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;setupGlobalEnvironment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;setupTargetTriple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;cm&#34;&gt;/*&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;   * Initialize the module.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;   */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;moduleInit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Open a new context and module.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;make_unique&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LLVMContext&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;make_unique&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Module&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Create a new builder for the module.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;make_unique&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IRBuilder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Vars builder:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;varsBuilder&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;make_unique&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IRBuilder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;setupExternFunctions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Implement here...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bytePtrTy&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getInt8Ty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getPointerTo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getOrInsertFunction&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;printf&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                &lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;FunctionType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                                        &lt;span class=&#34;cm&#34;&gt;/*return type*/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getInt32Ty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                                        &lt;span class=&#34;cm&#34;&gt;/*format args*/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bytePtrTy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                                        &lt;span class=&#34;cm&#34;&gt;/* vararg */&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Environment&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;enable_shared_from_this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Environment&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;   * Creates an environment with the given record.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;   */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;Environment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;record&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shared_ptr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Environment&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;record_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;record&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;parent_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//基本的作用域类&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TargetTriple&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sys&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getDefaultTargetTriple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;setTargetTriple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TargetTriple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;变量&#34;&gt;变量&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%8f%98%e9%87%8f&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;变量类型&#34;&gt;变量类型&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%8f%98%e9%87%8f%e7%b1%bb%e5%9e%8b&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;局部标识符总是使用前缀%，而全局标识符使用@。LLVM支持广泛的类型，但是下面是其最重要的类型： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;任意长度的整数，表示形式：iN；通常的例子是i32，i64，和i128。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;浮点类型，例如32位单精度浮点和64位双精度浮点。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;向量类型，表示格式：&amp;lt;&amp;lt;#elements&amp;gt; x &amp;lt;elementtype&amp;gt;&amp;gt;。包含四个i32元素的向量写为&amp;lt;4 x i32&amp;gt;。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;结构体类型 Structure Type 常用于存储类型的成员变量 &lt;br/&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-llvm&#34; data-lang=&#34;llvm&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;nv&#34;&gt;%T1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;     &lt;span class=&#34;c&#34;&gt;; Identified normal struct type&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;nv&#34;&gt;%T2&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;{&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&amp;gt;&lt;/span&gt;   &lt;span class=&#34;c&#34;&gt;; Identified packed struct type&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;nv&#34;&gt;%Pointer&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;区别在于packed 不会填充对齐 &lt;br/&gt;&#xA;构建方法： &lt;br/&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;StructType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cls&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;nullptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;n&#34;&gt;cls&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;StructType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;create&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;n&#34;&gt;cls&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;setBody&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;clsFields&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;clsFields 为 std::vector&amp;lt;llvm::Type *&amp;gt; 类型 即为llvm定义的类型如i32 i8. &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;变量作用范围&#34;&gt;变量作用范围&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%8f%98%e9%87%8f%e4%bd%9c%e7%94%a8%e8%8c%83%e5%9b%b4&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;figure&gt;&lt;img data-src=&#34;https://qisc123.github.io/imgs/variable.png&#34;&#xA;         data-action=&#34;zoom&#34;&#xA;         class=&#34;lazyload&#34;/&gt;&#xA;&lt;/figure&gt;&#xA; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;全局变量-global&#34;&gt;全局变量 global&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f-global&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;简单介绍：详情请看官方文档 &lt;br/&gt;&#xA;全局变量定义的是在编译时分配内存的区域，而不是在运行时分配。全局变量定义时必须进行初始化，其他翻译单元中的全局变量也可以被声明，此时它们没有初始化器。 &lt;br/&gt;&#xA;全局变量还可以选择性地指定链接类型。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;构建&lt;/p&gt;&#xA;&lt;p&gt;示例： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-llvm&#34; data-lang=&#34;llvm&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;vg&#34;&gt;@name&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;global&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;align&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;   * Creates a global variable.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;   */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GlobalVariable&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;createGlobalVar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                        &lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Constant&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getOrInsertGlobal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;init&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;variable&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getGlobalVariable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;variable&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;setAlignment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MaybeAlign&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;variable&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;setInitializer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;variable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;局部变量-stack&#34;&gt;局部变量 stack&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f-stack&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;存放到栈上的变量，对应于llvm ir alloca指令，在栈上分配空间，返回一个llvm::AllocaInst对象，可直接当成指针使用，store 到 alloca分配的地址。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-llvm&#34; data-lang=&#34;llvm&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;alloca&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;align&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;store&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;align&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;varBinding&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;allocVar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;varName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;varTy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CreateStore&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;varInit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;varBinding&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// store 值 到 对应位置&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;allocVar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;type_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Env&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;varsBuilder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SetInsertPoint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getEntryBlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//将局部变量插入到函数开始处，即entry 基本块&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;varAlloc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;varsBuilder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CreateAlloca&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c_str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//varsbuilder 永远保持在函数的entry基本块中专为生成变量时使用。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// Add to the environment:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;define&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;varAlloc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//设置作用域&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;varAlloc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;临时变量-register&#34;&gt;临时变量 register&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e4%b8%b4%e6%97%b6%e5%8f%98%e9%87%8f-register&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-llvm&#34; data-lang=&#34;llvm&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;%1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;add&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%3&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;%4&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;load&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;ptr&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%ptr&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;存储在寄存器的临时变量， 操作后的结果存放 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;op1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;gen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ast&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;op2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;gen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ast&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Op&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;op1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;op2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;varName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中Op可为CreateAdd 、CreateSub等函数。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;cond&#34;&gt;cond&lt;a class=&#34;anchorjs-link&#34; href=&#34;#cond&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;if&#34;&gt;if&lt;a class=&#34;anchorjs-link&#34; href=&#34;#if&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/cond.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&#xA;创建对应的3个基本块，生成对应的代码，插入br跳转指令，记得对应的基本块设置插入点,最后插入汇合块，同时插入phi函数，并设置前驱节点 &lt;br/&gt;&#xA;示例llvm ir代码： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-llvm&#34; data-lang=&#34;llvm&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;define&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;vg&#34;&gt;@max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nl&#34;&gt;entry:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nv&#34;&gt;%0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;imp&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sgt&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%b&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;br&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i1&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;label&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%then&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;label&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%else&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nl&#34;&gt;then:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;br&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;label&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%ifend&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nl&#34;&gt;else:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;br&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;label&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%ifend&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nl&#34;&gt;ifend:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nv&#34;&gt;%res&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;phi&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;%a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%then&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;%b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;%res&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;c++代码： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BasicBlock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;createBB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Function&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;nullptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;llvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BasicBlock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Create&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//若fn不为nullptr自动插入fn基本块列表的末尾&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cond&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;gen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ast&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;thenBlock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;createBB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;then&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;elseBlock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;createBB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;else&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ifEndBlock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;createBB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ifend&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CreateCondBr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cond&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;thenBlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;elseBlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SetInsertPoint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;thenBlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;thenRes&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;gen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ast&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CreateBr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ifEndBlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SetInsertPoint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;elseBlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;thenRes&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;gen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ast&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CreateBr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ifEndBlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SetInsertPoint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ifEndBlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;phi&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CreatePHI&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;thenRes&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;tmpif&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;phi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addIncoming&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;thenRes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;thenBlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;phi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addIncoming&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;elseRes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;elseBlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;phi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;嵌套if&#34;&gt;嵌套if&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%b5%8c%e5%a5%97if&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/cond-1.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&#xA;由于llvm ir 并无嵌套结构，而是一种顺序结构，所以内嵌的if也需要插入至少多个基本块，以至于外层phi节点需要连接的前驱节点出错(仍然连接第一个then基本块，明显是错误的)，此时外层的phi节点要连接内层的endif即merge基本块 所以需要取得最后插入blocklist的那个基本块，即，在处理if then,else的body后，需要保存其最后插入的基本块，并将其连接到phi。并且，else基本块需要在then基本块及其内嵌基本块之后插入，ifend同理。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cond&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;gen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ast&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;thenBlock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;createBB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;then&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;elseBlock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;createBB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;else&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//若fn=nullptr 将只创建基本块，不进行插入&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ifEndBlock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;createBB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ifend&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CreateCondBr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cond&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;thenBlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;elseBlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SetInsertPoint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;thenBlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;thenRes&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;gen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ast&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CreateBr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ifEndBlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;thenBlock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GetInsertBlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;fn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getBasicBlockList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push_back&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;elseBlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//fn-&amp;gt;insert(fn-&amp;gt;end(), elseBlock); 新版本使用&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SetInsertPoint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;elseBlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;elseRes&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;gen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ast&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CreateBr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ifEndBlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;elseBlock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GetInsertBlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;fn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getBasicBlockList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push_back&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ifEndBlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//fn-&amp;gt;insert(fn-&amp;gt;end(), ifEndBlock);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SetInsertPoint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ifEndBlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;phi&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CreatePHI&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;thenRes&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;tmpif&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;phi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addIncoming&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;thenRes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;thenBlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;phi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addIncoming&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;elseRes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;elseBlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;phi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Computer Architecture Part2</title>
      <link>https://qisc123.github.io/posts/2024/12/computer-architecture-part2/</link>
      <pubDate>Thu, 05 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://qisc123.github.io/posts/2024/12/computer-architecture-part2/</guid>
      <description>&lt;h2 id=&#34;流水线-pipeline&#34;&gt;流水线（Pipeline）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%b5%81%e6%b0%b4%e7%ba%bf-pipeline&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;将单条指令拆分成多个阶段执行后，当其执行到后一个阶段时，前一个阶段的硬件处于空闲状态，此时再发射一条指令从而复用硬件，就像工业流水线生产一样。 &lt;br/&gt;&#xA;更多并发 → 更高的指令吞吐量 &lt;br/&gt;&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/pipeline.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;停顿-stall-流水线停止前进的情况&#34;&gt;停顿（Stall）：流水线停止前进的情况&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%81%9c%e9%a1%bf-stall-%e6%b5%81%e6%b0%b4%e7%ba%bf%e5%81%9c%e6%ad%a2%e5%89%8d%e8%bf%9b%e7%9a%84%e6%83%85%e5%86%b5&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;停顿 = 指令等待其源操作数可用 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;停止所有上游阶段 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;清空所有下游阶段 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;禁用 PC 和 IF/ID 锁存器；确保停顿的指令保持在其当前阶段，在停顿指令之后的流水线阶段插入“无效”指令或空操作（称为“气泡”）。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;资源竞争-resource-contention&#34;&gt;资源竞争（Resource contention）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e8%b5%84%e6%ba%90%e7%ab%9e%e4%ba%89-resource-contention&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;当两个流水线阶段中的指令需要使用同一资源时发生 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;消除引起资源竞争的原因,复制资源或增加资源吞吐量 &lt;br/&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分离指令和数据存储器（缓存） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;为内存结构增加多个端口 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;检测资源竞争并暂停一个争用阶段 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;寄存器文件可在同一周期读写：写入发生在周期上半段, 读取发生在周期下半段, 但读/写操作只有半个时钟周期完成。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;指令间的依赖-dependences&#34;&gt;指令间的依赖（Dependences）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%8c%87%e4%bb%a4%e9%97%b4%e7%9a%84%e4%be%9d%e8%b5%96-dependences&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;数据依赖（Data）&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Flow dependence（写后读） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;figure&gt;&lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/raw.png&#34;&#xA;             data-action=&#34;zoom&#34;&#xA;             class=&#34;lazyload&#34;/&gt;&#xA;    &lt;/figure&gt;&#xA; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Anti dependence（读后写） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;figure&gt;&lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/war.png&#34;&#xA;             data-action=&#34;zoom&#34;&#xA;             class=&#34;lazyload&#34;/&gt;&#xA;    &lt;/figure&gt;&#xA; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Output dependence（写后写） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;figure&gt;&lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/waw.png&#34;&#xA;             data-action=&#34;zoom&#34;&#xA;             class=&#34;lazyload&#34;/&gt;&#xA;    &lt;/figure&gt;&#xA; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;解决方案&lt;/p&gt;&#xA;&lt;p&gt;后两种依赖：只需要在最后阶段、按程序顺序写入目标寄存器 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;处理 Flow 依赖的六种基本方法： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;检测并等待寄存器中值可用 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;检测并转发/旁路数据给依赖指令 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;检测并在软件层面消除依赖（无需硬件检测） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;检测并重新排序，使独立指令先执行 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;预测所需值，进行“推测执行”，然后验证 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;使用其他方式（如细粒度多线程），不需检测 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;可以添加一个硬件单元来检测依赖。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;控制依赖（Control）&lt;/p&gt;&#xA;&lt;p&gt;若取出的指令是控制流指令： &lt;br/&gt;&#xA;如何确定下一条 Fetch 的 PC？使用分支预测器。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;长延迟-多周期-操作-long-latency-operations&#34;&gt;长延迟（多周期）操作（Long-latency operations）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e9%95%bf%e5%bb%b6%e8%bf%9f-%e5%a4%9a%e5%91%a8%e6%9c%9f-%e6%93%8d%e4%bd%9c-long-latency-operations&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;由于长延迟指令占用硬件而造成的等待。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;数据转发-data-forwarding&#34;&gt;数据转发（Data Forwarding）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e8%bd%ac%e5%8f%91-data-forwarding&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;一旦结果可用，即将其转发给依赖的指令，从而降低停顿时间。 &lt;br/&gt;&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/data-forwarding.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;异常与中断-exceptions-and-interrupts&#34;&gt;异常与中断（Exceptions and Interrupts）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%bc%82%e5%b8%b8%e4%b8%8e%e4%b8%ad%e6%96%ad-exceptions-and-interrupts&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;程序执行过程中的“非计划”更改或中断: &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;异常（Exceptions）,源自程序内部的执行问题 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;中断（Interrupts）,来自需要处理的外部事件 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;处理异常和中断的共同步骤： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;停止当前程序 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;保存体系结构状态 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;处理异常/中断 → 切换到处理程序 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;（如可能且合理）返回程序执行 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;示例&#34;&gt;示例&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e7%a4%ba%e4%be%8b&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;&#xA;&lt;li&gt;异常：除以零、溢出、未定义操作码、访问保护错误、缺页错误等。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;中断：I/O 设备请求服务（如键盘输入、视频输入）、（周期性）系统定时器超时、电源故障、机器检查等。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;原因&#34;&gt;原因&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%8e%9f%e5%9b%a0&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;ul&gt;&#xA;&lt;li&gt;异常：来自当前运行线程内部 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;中断：来自线程外部 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;处理时机&#34;&gt;处理时机&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%a4%84%e7%90%86%e6%97%b6%e6%9c%ba&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;ul&gt;&#xA;&lt;li&gt;异常：在检测到且为非推测性异常时，立即处理 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;中断：在合适时机处理（除非是高优先级中断，如电源故障、机器检查） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;优先级：进程（异常），依赖情况（中断） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;处理上下文：进程（异常），系统（中断） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;保持精确以处理异常-中断-precise-exceptions-interrupts&#34;&gt;保持精确以处理异常/中断（Precise Exceptions/Interrupts）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e4%bf%9d%e6%8c%81%e7%b2%be%e7%a1%ae%e4%bb%a5%e5%a4%84%e7%90%86%e5%bc%82%e5%b8%b8-%e4%b8%ad%e6%96%ad-precise-exceptions-interrupts&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;保持精准是冯诺依曼架构成功的关键之一，如果不能做到这一点，调试程序将非常困难，对软件开发来说将是一种挑战。 &lt;br/&gt;&#xA;顺序提交指令的结果是保持程序正确和调试程序精准的关键。 &lt;br/&gt;&#xA;当准备处理异常/中断时，体系结构状态应保持一致（精确） &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;所有前面的指令应已完全完成 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;之后的指令不应已完成 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;当检测到最早可提交的指令导致异常时，控制逻辑将： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;确保架构状态精确（寄存器文件、PC、内存） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;清空流水线中所有较新的指令 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;保存 PC 和寄存器（由 ISA 规定） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;重定向取指引擎到相应的异常处理程序 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;保证精确异常&#34;&gt;保证精确异常&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e4%bf%9d%e8%af%81%e7%b2%be%e7%a1%ae%e5%bc%82%e5%b8%b8&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;单周期机器，每条指令保证在一个周期内完成，没有违反程序语义的风险 &lt;br/&gt;&#xA;多周期机器，需要在控制 FSM 中增加特殊状态，引导到异常/中断处理器，仅在精确状态（如取下一条指令之前）切换到处理程序 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;寄存器&lt;/p&gt;&#xA;&lt;p&gt;EPC 寄存器：保存引发异常的 PC &lt;br/&gt;&#xA;Cause 寄存器：保存异常的原因 &lt;br/&gt;&#xA;异常处理程序地址：如0x80000180 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;重排序缓冲区-reorder-buffer-rob&#34;&gt;重排序缓冲区（Reorder Buffer，ROB）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e9%87%8d%e6%8e%92%e5%ba%8f%e7%bc%93%e5%86%b2%e5%8c%ba-reorder-buffer-rob&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;允许指令乱序完成，即提交，但在结果可见前进行排序，当指令被译码时，分配 ROB 中的下一个顺序条目，指令完成时，将结果写入 ROB 条目，当该条目是 ROB 中最老的且没有异常，其结果写入寄存器或内存 &lt;br/&gt;&#xA;ROB 是一个硬件结构，记录所有译码但尚未提交的指令信息 &lt;br/&gt;&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/rob.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/rob2.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;使用 ROB 的寄存器重命名&lt;/p&gt;&#xA;&lt;p&gt;输出和反依赖并非真实依赖, 虽然是同一寄存器名，实际表示无关的值，由于 ISA 中寄存器数量有限，造成了假依赖 &lt;br/&gt;&#xA;解决方案：将寄存器 ID 重命名为其在 ROB 中的条目 ID &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;寄存器 ID → ROB 条目 ID &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;架构寄存器 ID → 物理寄存器 ID &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;使用 ROB ID 表示寄存器，消除假依赖，扩展寄存器数量 &lt;br/&gt;&#xA;寄存器重命名表（又称别名表） &lt;br/&gt;&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/rat.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;使用 ROB 的顺序流水线&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;译码阶段（D）：访问寄存器文件和 ROB，分配 ROB 条目，若可执行则调度到执行单元 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;执行阶段（E）：允许乱序完成 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;完成阶段（R）：将结果写入 ROB &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;退休/提交阶段（W）：检查最老指令是否异常；若无，则写入寄存器文件或内存；否则，清空流水线并跳转异常处理 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;顺序调度/执行，乱序完成，顺序提交 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;figure&gt;&lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/rob3.png&#34;&#xA;             data-action=&#34;zoom&#34;&#xA;             class=&#34;lazyload&#34;/&gt;&#xA;    &lt;/figure&gt;&#xA; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;指令乱序执行-动态调度&#34;&gt;指令乱序执行（动态调度）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%8c%87%e4%bb%a4%e4%b9%b1%e5%ba%8f%e6%89%a7%e8%a1%8c-%e5%8a%a8%e6%80%81%e8%b0%83%e5%ba%a6&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;调度：将指令发送到功能单元的行为 &lt;br/&gt;&#xA;当前的执行模型： &lt;br/&gt;&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/in-order-pipeline.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&#xA;可以看到不同处理单元所需的周期数是完全不同的，如果顺序发射指令可能会造成长时间的停顿。 &lt;br/&gt;&#xA;顺序流水线的问题： &lt;br/&gt;&#xA;未准备好的指令会阻塞其后的指令调度: &lt;br/&gt;&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/in-order-dispatch.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/out-of-order-dispatch.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;实现&#34;&gt;实现&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%ae%9e%e7%8e%b0&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;ol&gt;&#xA;&lt;li&gt;需要将使用某值的指令与生产者关联,使用寄存器重命名：为每个数据值分配一个“标签” &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;需要缓存指令，直到它们准备好执行,在重命名后插入保留站 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;指令需追踪源操作数的就绪状态,当一个值产生时，广播其“标签”,保留站中指令比较其源标签, 若匹配，则源值准备好 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;所有源值准备好时，调度指令到功能单元（FU）, 若多个指令准备好，每个 FU 需选择一个指令 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;figure&gt;&lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/rs.png&#34;&#xA;         data-action=&#34;zoom&#34;&#xA;         class=&#34;lazyload&#34;/&gt;&#xA;&lt;/figure&gt;&#xA; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;寄存器文件-rf-或寄存器别名表-rat&#34;&gt;寄存器文件（RF）或寄存器别名表（RAT）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%af%84%e5%ad%98%e5%99%a8%e6%96%87%e4%bb%b6-rf-%e6%88%96%e5%af%84%e5%ad%98%e5%99%a8%e5%88%ab%e5%90%8d%e8%a1%a8-rat&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;若 Valid 位为 1，表中值正确,否则，Tag 指出正确值的位置,Tag 是值将要被生产时的唯一标识符。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;所有执行单元都拥有保留站&#34;&gt;所有执行单元都拥有保留站&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%89%80%e6%9c%89%e6%89%a7%e8%a1%8c%e5%8d%95%e5%85%83%e9%83%bd%e6%8b%a5%e6%9c%89%e4%bf%9d%e7%95%99%e7%ab%99&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;h4 id=&#34;公共数据总线-cdb&#34;&gt;公共数据总线（CDB）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%85%ac%e5%85%b1%e6%95%b0%e6%8d%ae%e6%80%bb%e7%ba%bf-cdb&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;用于将计算出的值广播到可能需要它们的所有保留站 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;tomasulo-算法&#34;&gt;Tomasulo 算法&lt;a class=&#34;anchorjs-link&#34; href=&#34;#tomasulo-%e7%ae%97%e6%b3%95&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;ul&gt;&#xA;&lt;li&gt;若在重命名前有可用保留站： &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;将指令和重命名的操作数（值/标签）插入保留站 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;若无保留站，指令停顿 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;在保留站中，指令监听 CDB，等待其源操作数的标签 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;当标签匹配时，获取该值并保存在保留站中 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;当两个操作数都准备好后，指令准备调度 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;当指令完成后 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;申请 CDB &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;将带标签的值发送到 CDB（标签广播） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;寄存器文件连接到 CDB &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;寄存器包含表示最新写入者的标签 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;若标签匹配广播的标签，则写入值并设置有效位 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;回收重命名标签 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;系统中不再存在标签副本 → 可释放资源 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Computer Architecture Part1</title>
      <link>https://qisc123.github.io/posts/2024/11/computer-architecture-part1/</link>
      <pubDate>Fri, 15 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://qisc123.github.io/posts/2024/11/computer-architecture-part1/</guid>
      <description>&lt;h2 id=&#34;一种基本计算机模型&#34;&gt;一种基本计算机模型&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e4%b8%80%e7%a7%8d%e5%9f%ba%e6%9c%ac%e8%ae%a1%e7%ae%97%e6%9c%ba%e6%a8%a1%e5%9e%8b&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;冯·诺依曼模型&#xA;存储程序&#xA;顺序指令处理&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;内存（存储程序和数据）&lt;/li&gt;&#xA;&lt;li&gt;处理单元&lt;/li&gt;&#xA;&lt;li&gt;输入&lt;/li&gt;&#xA;&lt;li&gt;输出&lt;/li&gt;&#xA;&lt;li&gt;控制单元（控制指令执行的顺序）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/von-neumann.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/lc3.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;指令集&#34;&gt;指令集&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%8c%87%e4%bb%a4%e9%9b%86&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;ISA 是软件指令与硬件执行之间的接口&#xA;ISA指定了：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;内存组织&lt;/li&gt;&#xA;&lt;li&gt;地址空间（LC-3: 2^16，MIPS: 2^32）&lt;/li&gt;&#xA;&lt;li&gt;可寻址性（LC-3: 16 位，MIPS: 8 位）&lt;/li&gt;&#xA;&lt;li&gt;按字或按字节寻址&lt;/li&gt;&#xA;&lt;li&gt;寄存器集&#xA;LC-3 中有 8 个寄存器（R0 到 R7）&#xA;MIPS 中有 32 个寄存器&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;其包含：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;操作码&lt;/li&gt;&#xA;&lt;li&gt;数据类型&lt;/li&gt;&#xA;&lt;li&gt;寻址模式&lt;/li&gt;&#xA;&lt;li&gt;指令的长度和格式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;figure&gt;&lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/lc3-isa.png&#34;&#xA;         data-action=&#34;zoom&#34;&#xA;         class=&#34;lazyload&#34;/&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;指令主要分为三类：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;操作指令: 在 ALU 中执行操作&lt;/li&gt;&#xA;&lt;li&gt;数据移动指令: 从内存读取或写入到内存&lt;/li&gt;&#xA;&lt;li&gt;控制流指令: 改变执行顺序&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;操作指令&#34;&gt;操作指令&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%93%8d%e4%bd%9c%e6%8c%87%e4%bb%a4&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;在 LC-3 中，有三种操作指令：&#xA;NOT 是一元操作（一个源操作数), 执行按位非（bitwise NOT）, ADD 和 AND 是二元操作（两个源操作数）, ADD 是二进制补码加法, AND 是按位与 SR1 &amp;amp; SR2&#xA;在 MIPS 中，操作指令更多:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;大多数 R 类型指令（它们是二元操作）,例如：add，and，nor，xor……&lt;/li&gt;&#xA;&lt;li&gt;R 类型操作指令的 I 类型版本（即一个立即数操作数）&lt;/li&gt;&#xA;&lt;li&gt;F 类型操作， 即浮点操作&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;数据移动指令和寻址模式&#34;&gt;数据移动指令和寻址模式&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e7%a7%bb%e5%8a%a8%e6%8c%87%e4%bb%a4%e5%92%8c%e5%af%bb%e5%9d%80%e6%a8%a1%e5%bc%8f&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;在 LC-3 中，有七种数据移动指令：&#xA;LD、LDR、LDI、LEA、ST、STR、STI&#xA;加载和存储指令的格式：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;操作码（位 [15:12]）&lt;/li&gt;&#xA;&lt;li&gt;目标寄存器或源寄存器（位 [11:9]）&lt;/li&gt;&#xA;&lt;li&gt;地址生成位（位 [8:0]）&lt;/li&gt;&#xA;&lt;li&gt;有四种位解释方式，称为寻址模式：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;PC 相对模式&lt;/li&gt;&#xA;&lt;li&gt;间接模式&lt;/li&gt;&#xA;&lt;li&gt;基址+偏移模式&lt;/li&gt;&#xA;&lt;li&gt;立即数模式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在 MIPS 中，加载和存储指令只有基址+偏移和立即数两种模式&lt;/p&gt;&#xA;&lt;h3 id=&#34;控制流指令&#34;&gt;控制流指令&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%8e%a7%e5%88%b6%e6%b5%81%e6%8c%87%e4%bb%a4&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;条件跳转与无条件跳转&lt;/p&gt;&#xA;&lt;h3 id=&#34;数据类型&#34;&gt;数据类型&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;指令集支持更多数据类型的优势：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;能更好地将高级语言构造映射到硬件&lt;/li&gt;&#xA;&lt;li&gt;硬件能直接操作编程语言中的数据类型 → 更少的指令数量和代码体积&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;例如：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;矩阵操作 vs. 单独的乘法/加法/加载/存储指令&lt;/li&gt;&#xA;&lt;li&gt;图结构操作 vs. 单独的加载/存储/加法/…指令&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;劣势：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;微架构设计者需做更多工作&lt;/li&gt;&#xA;&lt;li&gt;需要实现操作数据类型的指令&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;涉及权衡tradeoff&#34;&gt;涉及权衡tradeoff&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%b6%89%e5%8f%8a%e6%9d%83%e8%a1%a1tradeoff&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;&#xA;&lt;li&gt;硬件复杂性 vs. 软件复杂性&lt;/li&gt;&#xA;&lt;li&gt;简单指令 vs. 复杂指令的延迟&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;figure&gt;&lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/datatype.png&#34;&#xA;         data-action=&#34;zoom&#34;&#xA;         class=&#34;lazyload&#34;/&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;h2 id=&#34;汇编-编程&#34;&gt;（汇编）编程&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%b1%87%e7%bc%96-%e7%bc%96%e7%a8%8b&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;编程构造&#34;&gt;编程构造&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e7%bc%96%e7%a8%8b%e6%9e%84%e9%80%a0&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;编程需要将一个任务（即一个工作单元）划分为多个更小的工作单元,目标是将工作单元替换为能表示该部分任务的编程构造。&#xA;有三种基本的编程构造：&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/program-cons.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;顺序构造&#xA;如果任务可分为两个子任务，且一个接一个执行，使用顺序构造&lt;/li&gt;&#xA;&lt;li&gt;条件构造&#xA;如果任务是两个子任务中执行一个（而不是两个都执行），使用条件构造&#xA;任一子任务可以是“无操作”&#xA;执行完正确子任务后，程序继续执行&lt;/li&gt;&#xA;&lt;li&gt;迭代构造&#xA;如果任务是重复执行某个子任务，但前提是某个条件为真，使用迭代构造&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;指令周期&#34;&gt;指令周期&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%8c%87%e4%bb%a4%e5%91%a8%e6%9c%9f&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;指令周期是一个指令被执行时经历的一系列步骤或阶段:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;FETCH（取指）&lt;/li&gt;&#xA;&lt;li&gt;DECODE（译码）&lt;/li&gt;&#xA;&lt;li&gt;EVALUATE ADDRESS（计算地址）&lt;/li&gt;&#xA;&lt;li&gt;FETCH OPERANDS（取操作数）&lt;/li&gt;&#xA;&lt;li&gt;EXECUTE（执行）&lt;/li&gt;&#xA;&lt;li&gt;STORE RESULT（存结果）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;不是所有指令都需要六个阶段:&#xA;LDR 不需要 EXECUTE&#xA;ADD 不需要 EVALUATE ADDRESS&#xA;Intel x86 指令 ADD [eax], edx 是具有六个阶段的指令示例&lt;/p&gt;&#xA;&lt;h3 id=&#34;指令周期的控制单元&#34;&gt;指令周期的控制单元&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%8c%87%e4%bb%a4%e5%91%a8%e6%9c%9f%e7%9a%84%e6%8e%a7%e5%88%b6%e5%8d%95%e5%85%83&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;一个使用真值表构建的自动机&lt;/p&gt;&#xA;&lt;h3 id=&#34;处理指令-步骤&#34;&gt;“处理指令”步骤&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%a4%84%e7%90%86%e6%8c%87%e4%bb%a4-%e6%ad%a5%e9%aa%a4&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;AS = 时钟周期开始时的架构状态（程序员可见）&#xA;AS&amp;rsquo; = 时钟周期结束时的架构状态（程序员可见）&#xA;一个非常基础的指令处理引擎,每条指令在一个时钟周期内执行, 只使用组合逻辑实现指令执行,没有中间、程序员不可见的状态更新。&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/as2.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;isa-级别抽象视角&#34;&gt;ISA 级别抽象视角&lt;a class=&#34;anchorjs-link&#34; href=&#34;#isa-%e7%ba%a7%e5%88%ab%e6%8a%bd%e8%b1%a1%e8%a7%86%e8%a7%92&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;从 ISA 视角看，指令执行期间 AS 和 AS&amp;rsquo; 之间没有“中间状态”,每条指令一个状态转换。&#xA;它定义了一个抽象的有限状态机，其中：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;状态 = 程序员可见状态&lt;/li&gt;&#xA;&lt;li&gt;下一状态逻辑 = 指令执行后的结果&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;实现-as-到-as-的转化方式&#34;&gt;实现 AS 到 AS&amp;rsquo; 的转化方式&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%ae%9e%e7%8e%b0-as-%e5%88%b0-as-%e7%9a%84%e8%bd%ac%e5%8c%96%e6%96%b9%e5%bc%8f&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;有多种实现：&#xA;我们可以有程序员不可见的状态以优化指令执行速度：每条指令多个状态转换&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;AS -&amp;gt; AS&amp;rsquo;（一个时钟周期内转换）&lt;/li&gt;&#xA;&lt;li&gt;AS -&amp;gt; AS+MS1 -&amp;gt; AS+MS2 -&amp;gt; AS+MS3 -&amp;gt; AS&amp;rsquo;（多个时钟周期）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;微架构基础与设计&#34;&gt;微架构基础与设计&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%be%ae%e6%9e%b6%e6%9e%84%e5%9f%ba%e7%a1%80%e4%b8%8e%e8%ae%be%e8%ae%a1&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;组成&#34;&gt;组成&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e7%bb%84%e6%88%90&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;h4 id=&#34;数据通路-由处理和转换数据信号的硬件组成&#34;&gt;数据通路：由处理和转换数据信号的硬件组成&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e9%80%9a%e8%b7%af-%e7%94%b1%e5%a4%84%e7%90%86%e5%92%8c%e8%bd%ac%e6%8d%a2%e6%95%b0%e6%8d%ae%e4%bf%a1%e5%8f%b7%e7%9a%84%e7%a1%ac%e4%bb%b6%e7%bb%84%e6%88%90&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;功能单元：对数据进行操作&#xA;硬件结构（如导线、多路选择器、解码器、三态缓冲器）：使数据流入功能单元和寄存器&#xA;存储单元：存储数据（如寄存器）&lt;/p&gt;&#xA;&lt;h4 id=&#34;控制逻辑-由决定控制信号的硬件组成-即指定数据通路元素对数据执行什么操作的信号&#34;&gt;控制逻辑：由决定控制信号的硬件组成，即指定数据通路元素对数据执行什么操作的信号&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%8e%a7%e5%88%b6%e9%80%bb%e8%be%91-%e7%94%b1%e5%86%b3%e5%ae%9a%e6%8e%a7%e5%88%b6%e4%bf%a1%e5%8f%b7%e7%9a%84%e7%a1%ac%e4%bb%b6%e7%bb%84%e6%88%90-%e5%8d%b3%e6%8c%87%e5%ae%9a%e6%95%b0%e6%8d%ae%e9%80%9a%e8%b7%af%e5%85%83%e7%b4%a0%e5%af%b9%e6%95%b0%e6%8d%ae%e6%89%a7%e8%a1%8c%e4%bb%80%e4%b9%88%e6%93%8d%e4%bd%9c%e7%9a%84%e4%bf%a1%e5%8f%b7&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;figure&gt;&lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/lc3-consist.png&#34;&#xA;         data-action=&#34;zoom&#34;&#xA;         class=&#34;lazyload&#34;/&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;h3 id=&#34;单周期机器&#34;&gt;单周期机器&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%8d%95%e5%91%a8%e6%9c%9f%e6%9c%ba%e5%99%a8&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;&#xA;&lt;li&gt;每条指令只需一个时钟周期&lt;/li&gt;&#xA;&lt;li&gt;所有状态更新在指令执行结束时进行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;主要缺点：最慢的指令决定周期时间 → 时钟周期时间长&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/single-cycle.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;多周期机器&#34;&gt;多周期机器&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%a4%9a%e5%91%a8%e6%9c%9f%e6%9c%ba%e5%99%a8&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;通过在各个阶段添加寄存器保存当前阶段的执行结果，从而能将指令进行拆分。&#xA;一条指令需要多个时钟周期：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;指令取指（IF）&lt;/li&gt;&#xA;&lt;li&gt;指令译码和寄存器操作数取值（ID/RF）&lt;/li&gt;&#xA;&lt;li&gt;执行/计算内存地址（EX/AG）&lt;/li&gt;&#xA;&lt;li&gt;内存操作数取值（MEM）&lt;/li&gt;&#xA;&lt;li&gt;存储/写回结果（WB）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;指令处理被分解为多个周期/阶段, 在指令执行过程中可以更新状态，架构状态在指令执行结束时更新。&#xA;相比单周期的优势：最慢的“阶段”决定周期时间&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/comp-arch/multi-cycles.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;性能分析&#34;&gt;性能分析&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;CPI: Cycles Per Instruction&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单条指令的执行时间: {CPI} × {时钟周期时间}&lt;/li&gt;&#xA;&lt;li&gt;整个程序的执行时间: 所有指令之和 [{CPI} × {时钟周期时间}], 即{指令数} × {平均 CPI} × {时钟周期时间}&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;单周期微架构性能&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CPI = 1&lt;/li&gt;&#xA;&lt;li&gt;时钟周期时间 = 长&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;多周期微架构性能&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CPI = 每条指令不同&lt;/li&gt;&#xA;&lt;li&gt;时钟周期时间 = 短&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Data Flow Analysis</title>
      <link>https://qisc123.github.io/posts/2024/05/data-flow-analysis/</link>
      <pubDate>Wed, 22 May 2024 00:00:00 +0800</pubDate>
      <guid>https://qisc123.github.io/posts/2024/05/data-flow-analysis/</guid>
      <description>&lt;h2 id=&#34;数据流分析&#34;&gt;数据流分析&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e6%b5%81%e5%88%86%e6%9e%90&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;依托于控制流结构,即以基本块为单位的CFG(control-flow-graph)。本质上是计算每一个变量的数据依赖关系。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;遍历方式&#34;&gt;遍历方式&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e9%81%8d%e5%8e%86%e6%96%b9%e5%bc%8f&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;前向数据流 forward analysis rpo 逆后序 &lt;br/&gt;&#xA;后向数据流 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;迭代数据流分析&#34;&gt;迭代数据流分析&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e8%bf%ad%e4%bb%a3%e6%95%b0%e6%8d%ae%e6%b5%81%e5%88%86%e6%9e%90&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;解方程组 &lt;br/&gt;&#xA;解决CFG中环的问题 &lt;br/&gt;&#xA;通过将节点的相应集合设为最大，即全部集合的并集 &lt;br/&gt;&#xA;通过不断的取交集进行缩小集合最后达到不动点退出迭代 &lt;br/&gt;&#xA;In 代表 进入节点 Out 代表 退出节点 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;支配性&#34;&gt;支配性&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%94%af%e9%85%8d%e6%80%a7&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;在入口节点为b0的流图中，当且仅当节点bi​位于从b0​到节点bj​的所有路径上时，称节点bi​支配​​（dominates）节点bj​，记作bi​ dom bj​。 &lt;br/&gt;&#xA;dom(n) 为支配n的节点集合 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;br/&gt;&#xA;&lt;p&gt;\(\text{DOM}(n) = \{n\} \cup \left( \cap_{m \in \text{preds}(n)} \text{DOM}(m) \right)\) &lt;br/&gt;&#xA;初始值： &lt;br/&gt;&#xA;\(\text{DOM}(n_0) = \{n_0\},\quad \text{DOM}(n) = N,\, \forall n \ne n_0\) &lt;br/&gt;&#xA;其中，N为CFG中所有节点的集合。 &lt;br/&gt;&#xA;完整算法： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;\begin{aligned}&#xA;&amp;amp;\text{DOM}(0) \leftarrow \{0\} \\&#xA;&amp;amp;\text{for } i \leftarrow 1 \text{ to } |N| - 1 \text{ do} \\&#xA;&amp;amp;\quad \text{DOM}(i) \leftarrow N \\&#xA;&amp;amp;\text{changed} \leftarrow \text{true} \\&#xA;&amp;amp;\text{while (changed) do} \\&#xA;&amp;amp;\quad \text{changed} \leftarrow \text{false} \\&#xA;&amp;amp;\quad \text{for } i \leftarrow 1 \text{ to } |N| - 1 \text{ do} \\&#xA;&amp;amp;\qquad \text{temp} \leftarrow \{i\} \cup \left(\cap_{j \in \text{preds}(i)} \text{DOM}(j) \right) \\&#xA;&amp;amp;\qquad \text{if } \text{temp} \ne \text{DOM}(i) \text{ then} \\&#xA;&amp;amp;\qquad\quad \text{DOM}(i) \leftarrow \text{temp} \\&#xA;&amp;amp;\qquad\quad \text{changed} \leftarrow \text{true}&#xA;\end{aligned}&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;衍生定义&lt;/p&gt;&#xA;&lt;p&gt;严格支配： &lt;br/&gt;&#xA;当d！=n时且d dom n ，则d sdom n &lt;br/&gt;&#xA;直接支配： &lt;br/&gt;&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/optimization/dominator-tree.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&#xA;在支配树（dominator tree）中，对于结点 n 来说，从根节点到结点 n 所在路径上的结点（不包括n）都严格支配结点 n，例如上图中从根节点 1 -&amp;gt; 2 -&amp;gt; 3，其中结点 1 和 结点 2 都严格支配结点 3。该路径上离结点 n 最近的结点叫做结点 n 的 直接支配结点（immediate ），用 IDom(n) 表示，例如上图中 IDom(6) = 2。换句话说，就是在严格支配性的基础上还得是节点n前的最后一个严格支配节点。 &lt;br/&gt;&#xA;支配边界： &lt;br/&gt;&#xA;Y 是 X 的支配边界，当且仅当 X 支配 Y 的一个前驱结点（CFG）同时 X 并不严格支配 Y &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;效率&lt;/p&gt;&#xA;&lt;p&gt;逆后序遍历 后序遍历的反面 优先遍历父节点 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;活动性&#34;&gt;活动性&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%b4%bb%e5%8a%a8%e6%80%a7&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Live variable &lt;br/&gt;&#xA;A variable v is live at point p if there exists a path from p to a use of v along which v is not redefined &lt;br/&gt;&#xA;\(\text{{LiveOut}}(n) = \bigcup_{m \in \text{{succ}}(n)} (\text{{UEVar}}(m) \cup (\text{{LiveOut}}(m) \cap \overline{ \text{{VARKill}}(m)}))\) &lt;br/&gt;&#xA;在m中定义了的变量和没有定义的变量 &lt;br/&gt;&#xA;UEVar(m)在m中向上展开的变量的集合 &lt;br/&gt;&#xA;VARKill(m) 在m中重新定义的变量 &lt;br/&gt;&#xA;向上展开：x在m中重新定义之前，使用了x的引用 &lt;br/&gt;&#xA;如果v在m的入口处存活，要么 v在 m中重新定义并且在重新定义前对其引用，要不穿过m在m的后继过程的开始处存活没有在m中重新定义 &lt;br/&gt;&#xA;初始值： &lt;br/&gt;&#xA;\(\text{LiveOut}(n) = \emptyset, \forall n\) &lt;br/&gt;&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;作用&lt;/p&gt;&#xA;&lt;p&gt;查找未初始化的变量 可能查找的结果有误 &lt;br/&gt;&#xA;全局寄存器分配 &lt;br/&gt;&#xA;ssa构建的改进，不活动的变量不需要插入phi函数 &lt;br/&gt;&#xA;无用的store操作 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;可用表达式&#34;&gt;可用表达式&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%8f%af%e7%94%a8%e8%a1%a8%e8%be%be%e5%bc%8f&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;\(\text{AVAILIN}(n) = \bigcap_{m \in \text{preds}(n)} \left( \text{DEExpr}(m) \cup \left( \text{AvailIn}(m) \cap \overline{\text{ExprKill}(m)} \right) \right)\) &lt;br/&gt;&#xA;在n中可用的表达式包含了在m中表达式定义过的和没有定义过的表达式。 &lt;br/&gt;&#xA;每个节点的初始值：\(\text{AVAILIN}(n_0) = \emptyset\) 且 \(\text{AVAILIN}(n) = \{ \text{all expressions} \}, \forall n \neq n_0\) &lt;br/&gt;&#xA;DEExpr(n)代表着第n个块中的向下展开表达式集合。一个表达式e∈DEEXPR(n)当且仅当块n计算了e，并且e的操作数在块n中对e的最后一次计算到块n的结束之间没有被定义。EXPRKILL(n)包含所有被块n中的定义所杀死的表达式。如果一个或多个操作数在块中被重新定义，那么表达式就会被杀死。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;如果一个表达式e在进入块n时可用，那么它在CFG中n的每个前驱块的退出时也可用。正如方程所述，如果一个表达式e在某个块m的退出时可用，那么有两个条件之一成立：要么e在m中向下暴露，要么它在进入m时可用并且在m中没有被杀死。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;作用&lt;/p&gt;&#xA;&lt;p&gt;AVAILIN集合在全局冗余消除中使用，有时被称为全局公共子表达式消除。实现这一效果的最简单方法可能是为每个块计算AVAILIN集合，并将它们用作本地值编号的初始信息。惰性代码移动是一种更强大的冗余消除形式，也使用可用性。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;可达&#34;&gt;可达&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%8f%af%e8%be%be&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;\(\text{Reaches}(n) = \bigcup_{m \in \text{preds}(n)} ( \text{DEDef}(m) \cup (\text{Reaches}(m) \cap \overline{\text{DefKill}(m)}))\) &lt;br/&gt;&#xA;初始值: &lt;br/&gt;&#xA;\(\text{REACHES}(n) = \emptyset, \forall n\) &lt;br/&gt;&#xA;n的入口 &lt;br/&gt;&#xA;在m中操作数定义过 和 没有定义过即穿过m 到可达 &lt;br/&gt;&#xA;看上去和存活分析中的var很像，但是这里还包含了位置信息 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;作用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;可预测&#34;&gt;可预测&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%8f%af%e9%a2%84%e6%b5%8b&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;\(\text{AntOut}(n) = \bigcap_{m \in \text{succ}(n)} (\text{UEExpr}(m) \cup (\text{AntOut}(m) \cap  \overline{\text{ExprKill}(m)}))\) &lt;br/&gt;&#xA;\(\text{AntOut}(n_f) = \emptyset,\  \text{AntOut}(n) = \{ \text{all expressions} \}, \forall n \neq n_f\) &lt;br/&gt;&#xA;在所有n的后继结点中的第一次计算e与n中的最后一次计算e的值相同的表达式集合。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;作用&lt;/p&gt;&#xA;&lt;p&gt;代码移动 1节约时间缓式代码移动 2空间上 减少代码长度 代码提升 code hoisting &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;过程间综述问题&#34;&gt;过程间综述问题&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e8%bf%87%e7%a8%8b%e9%97%b4%e7%bb%bc%e8%bf%b0%e9%97%ae%e9%a2%98&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;可能修改 may modify &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;静态单赋值形式&#34;&gt;静态单赋值形式&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e9%9d%99%e6%80%81%e5%8d%95%e8%b5%8b%e5%80%bc%e5%bd%a2%e5%bc%8f&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;严格支配 &lt;br/&gt;&#xA;支配区域 &lt;br/&gt;&#xA;支配边界 DF(n) 与 Dom(n)反过来 &lt;br/&gt;&#xA;支配者树 &lt;br/&gt;&#xA;汇合点 &lt;br/&gt;&#xA;Critical edge &lt;br/&gt;&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;构建ssa形式&lt;/p&gt;&#xA;&lt;p&gt;先根次序遍历支配者树，重命名变量，插入phi函数 &lt;br/&gt;&#xA;最大最小 半剪枝 剪枝 liveness &lt;br/&gt;&#xA;全局变量 变量在哪些blocks中存在 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;解除ssa形式，SSA Deconstruction&lt;/p&gt;&#xA;&lt;p&gt;去除phi函数 在前驱节点插入赋值 ，评估存活性，插入临时变量 &lt;br/&gt;&#xA;去除变量名下标？ &lt;br/&gt;&#xA;copy folding 造成的问题 &lt;br/&gt;&#xA;?? eac third ver. p491 对phi函数隔离命名空间的一系列操作 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;全局常量传播&lt;/p&gt;&#xA;&lt;p&gt;sscp算法 &lt;br/&gt;&#xA;sccp &lt;br/&gt;&#xA;半格 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;If n is defined by a φ-function, SSCP sets Value(n) to top. &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;if n’s value is not known, SSCP sets Value(n) to top. &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;If n’s value is a known constant ci, SSCP sets Value(n) to ci. &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;If n’s value cannot be known—for example, it is defined by reading a &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;value from external media—SSCP sets Value(n) to ⊥(buttom). &lt;br/&gt;&#xA;If Value(n) is not top, the algorithm adds n to the worklist. &lt;br/&gt;&#xA;有三种值，代表一个变量的三种情况，当前未知，确定为常量，确定为变量。 &lt;br/&gt;&#xA;然后三种值进行meet运算是单向的从top到Constant到bot ，具体规则见书eac p383 &lt;br/&gt;&#xA;首先把常数和变量 即已知的值放入worklist,然后使用def-use,推导计算所有的使用这些量的def,如果与先前初始化的值不同，那么放入worklist,重新计算 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;过程间分析&#34;&gt;过程间分析&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e8%bf%87%e7%a8%8b%e9%97%b4%e5%88%86%e6%9e%90&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;解决两个问题 &lt;br/&gt;&#xA;1.过程调用对单过程优化的影响 &lt;br/&gt;&#xA;构建调用图 处理过程间常量传播 &lt;br/&gt;&#xA;2.维护过程调用固有抽象的开销 &lt;br/&gt;&#xA;过程间常量传播 &lt;br/&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Context Free Grammar</title>
      <link>https://qisc123.github.io/posts/2024/05/context-free-grammar/</link>
      <pubDate>Fri, 03 May 2024 00:00:00 +0800</pubDate>
      <guid>https://qisc123.github.io/posts/2024/05/context-free-grammar/</guid>
      <description>&lt;h2 id=&#34;上下文无关文法概述&#34;&gt;上下文无关文法概述&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e4%b8%8a%e4%b8%8b%e6%96%87%e6%97%a0%e5%85%b3%e6%96%87%e6%b3%95%e6%a6%82%e8%bf%b0&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;下面给出一个上下文无关文法的示例，称其为 \(G_{1}\): &lt;br/&gt;&#xA;A \(\rightarrow\) 0A1 &lt;br/&gt;&#xA;A \(\rightarrow \) B &lt;br/&gt;&#xA;B \(\rightarrow\) # &lt;br/&gt;&#xA;一个文法由一组替换规则（substitution rule）组成，替换规则又称为产生式(production)。 &lt;br/&gt;&#xA;每条规则占一行，由一个符号和一个字符串构成，符号和字符串之间用箭头隔开。符号称为变元(variable)，字符串由变元和另一种称为终结符(terminal)的符号组成。 &lt;br/&gt;&#xA;变元常用大写字母表示，终结符类似于输入字符，常用小写字母、数字或特殊符号表示。 &lt;br/&gt;&#xA;一个变元被指定为起始变元(start variable)，通常它出现在第一条规则的左边。在上述示例中，文法G&lt;sub&gt;1&lt;/sub&gt;有3条规则，A和B是变元，其中A是起始变元，0、1和#是终结符。 &lt;br/&gt;&#xA;获取一个字符串的替换序列称为派生(derivation)。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;按照以下方法，能够根据文法生成其所描述的语言的每一个字符串: &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;写下起始变元。它是第一条规则左边的变元，除非另有指定。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;取一个已写下的变元，并找到以该变元开始的规则，把这个变元替换成规则右边的字符串。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;重复步骤2，直到写下的字符串没有变元为止。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;例: 由G1生成字符串000#111的派生过程为: &lt;br/&gt;&#xA;A⇒0A1⇒00A11⇒000A111⇒000B111⇒000#111 &lt;br/&gt;&#xA;这个过程可以用一颗语法分析树形象的表达。 &lt;br/&gt;&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/context-free-grammar/grammar-tree.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;定义&#34;&gt;定义&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%ae%9a%e4%b9%89&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;上下文无关文法（context-free grammar）是一个4元组 \[(V, \Sigma, R, S)\]，且 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;\(V\) 是一个有穷集合，称为变元集（variables）。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(\Sigma\) 是一个与 \(V\) 不相交的有穷集合，称为终结符集(terminals)。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(R\) 是一个有穷规则集（rules），每条规则由一个变元和一个由变元及终结符组成的 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;字符串构成。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;\( S \in V\) 是起始变元。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;设u，v和w是由变元及终结符构成的字符串，A→w是文法的一条规则，称uAv生成(yield) uvw，记作uAv⇒uwv。 &lt;br/&gt;&#xA;如果u=v，或者存在序列u1，u2，⋯，uk，使得 &lt;br/&gt;&#xA;u⇒ u1 ⇒u2 ⇒&amp;hellip;⇒uk ⇒v &lt;br/&gt;&#xA;其中k≥0，则称u派生v，记作\(u \overset{*}{\Rightarrow}v \)。该文法的语言是 \(\{ w \in \Sigma^* \mid S \overset{*}{\Rightarrow} w \}\)。 &lt;br/&gt;&#xA;在文法G&lt;sub&gt;1&lt;/sub&gt;中，V = {A, B}, Σ = {0, 1, #}, S = A, 而R是上面提到的示例中给出的3条规则。 &lt;br/&gt;&#xA;在描述一个文法时，通常只写出它的规则。出现在规则左边的所有符号都是变元，其余的符号都是终结符，按照惯例，起始变元是第一条规则左边的变元。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;下推自动机dpa&#34;&gt;下推自动机DPA&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e4%b8%8b%e6%8e%a8%e8%87%aa%e5%8a%a8%e6%9c%badpa&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;下推自动机在之前的NFA,DFA的基础上加上了一个栈，以此来存储信息，非确定性下推自动机等价于上下文无关语法。下推自动机与NFA,DFA最大不同在于能够存储之前状态的信息，从而能够进行嵌套的状态转移。 &lt;br/&gt;&#xA;现代编程语言的语法解析器大多使用了确定性下推自动机。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;下推自动机（Pushdown Automaton, PDA）是一个六元组 \( (Q, \Sigma, \Gamma, \delta, q_0, F)\)，其中 \(Q\)、\(\Sigma\)、\(\Gamma\) 和 \(F\) 都是有限集合，具体含义如下： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;\(Q\) 是状态集合， &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(\Sigma\) 是输入字母表， &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(\Gamma\) 是栈字母表， &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(\delta\) 是状态转移函数，其形式为：  &lt;br/&gt;&#xA;\(\delta : Q \times \Sigma_\varepsilon \times \Gamma_\varepsilon \to \mathcal{P}(Q \times \Gamma_\varepsilon)\), 其中 \(\Sigma_\varepsilon\)表示 \(\Sigma \cup \{\varepsilon\}\)，\(\Gamma_\varepsilon\) 表示 \(\Gamma \cup \{\varepsilon\}\)，\(\mathcal{P}\)表示幂集，即：状态转移由当前状态、输入符号（或 ε）、栈顶符号（或 ε）决定，输出为一组可能的（新状态, 栈操作）对。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(q_0 \in Q\) 是初始状态， &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\( F \subseteq Q \) 是接受状态集合 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/div&gt;&#xA;&lt;h3 id=&#34;确定性下推自动机&#34;&gt;确定性下推自动机&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e7%a1%ae%e5%ae%9a%e6%80%a7%e4%b8%8b%e6%8e%a8%e8%87%aa%e5%8a%a8%e6%9c%ba&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;对应于确定型上下文无关语言(DCFL)。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;确定性下推自动机(deterministic pushdown automaton, DPDA),区别在于转移函数。对于每一组输入和栈顶值只有一种转移，但是它保留了 \(\epsilon-move\) 转移。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;\(\delta : Q \times \Sigma \cup \{\varepsilon\} \times \Gamma \cup \{\varepsilon\} \to (Q \times \Gamma \cup \{\varepsilon\}) \cup \{\emptyset\}\) &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;语法分析&#34;&gt;语法分析&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在语法分析（尤其是形式语言理论和自动机理论）中，希腊字母、大写英文字母和小写英文字母通常用于表示不同的语法成分或符号类别。以下是常见的约定及其含义： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;希腊字母（如 α, β, γ, δ）​​​表示符号串（String of Symbols）,通常代表由终结符和非终结符组成的​​任意符号串​​（可能是空串）。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;​大写英文字母（如 A, B, C, S）​​表示非终结符（Non-terminal Symbols）​​,非终结符代表语法中的变量或抽象语法类别，可以进一步展开为其他符号。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;​​小写英文字母（如 a, b, c, x, y）​​表示终结符（Terminal Symbols）​​,终结符是语法中的基本符号，不可再分解，通常对应语言中的实际单词或字符。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;​​其他常见符号​​ &lt;br/&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;​大写字母（如 V,Σ）​​Σ：终结符的集合（Alphabet） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;V 或 N：非终结符的集合 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;V∪Σ：所有符号的集合（文法符号） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;​大写字母 + 下标（如A1​,B 2​）​​用于区分同类非终结符（如 &amp;lt;expr&amp;gt; 1​和 &amp;lt;expr&amp;gt; 2​)。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;first集&#34;&gt;First集&lt;a class=&#34;anchorjs-link&#34; href=&#34;#first%e9%9b%86&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;\begin{equation*}&#xA;\mathrm{FIRST}(\alpha) =&#xA;\{ a \in \Sigma \mid \alpha \overset{*}{\Rightarrow} a \beta \}&#xA;\cup&#xA;\begin{cases}&#xA;\{\varepsilon\}, &amp;amp; \text{ if } \alpha \overset{*}{\Rightarrow} \varepsilon \\&#xA;\emptyset, &amp;amp; \text{else}&#xA;\end{cases}&#xA;\end{equation*}&lt;/p&gt;&#xA;&lt;p&gt;FIRST(α)为α的开始的终结符的集合。 &lt;br/&gt;&#xA;基本算法 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;若\( \alpha \)以终结符a开头，则\( a \in \mathrm{FIRST}(\alpha)\) &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;若 \( \alpha \) 以非终结符 \( A \) 开头，则将 \( \mathrm{FIRST}(A)\) 加入 \( \mathrm{FIRST}(\alpha) \)； &lt;br/&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;若 \( \varepsilon \in \mathrm{FIRST}(A) \)，则继续考察 \( A \) 之后的符号， &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;否则停止。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;若 \( \alpha \) 的所有符号都能推出 \( \varepsilon \)，则 \( \varepsilon \in \mathrm{FIRST}(\alpha) \)。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;follow集&#34;&gt;Follow集&lt;a class=&#34;anchorjs-link&#34; href=&#34;#follow%e9%9b%86&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;\begin{equation*}&#xA;\mathrm{FOLLOW}(A) =&#xA;\{ a \in \Sigma \mid S \overset{*}{\Rightarrow} \alpha A a \beta \}&#xA;\cup&#xA;\begin{cases}&#xA;\{\$\}, &amp;amp; \text{ if } S \overset{*}{\Rightarrow} \gamma A \\&#xA;\emptyset, &amp;amp; \text{else}&#xA;\end{cases}&#xA;\end{equation*}&lt;/p&gt;&#xA;&lt;p&gt;FOLLOW(A)为非终结符A的后跟符号集合。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;若 \( A \) 是开始符号，则将 \(\$ \)（即输入的结束符号）加入 \( \mathrm{FOLLOW}(A) \)。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;若存在产生式 \( B \rightarrow \alpha A \beta \)，则将 \( \mathrm{FIRST}(\beta)  \) 加入 \( \mathrm{FOLLOW}(A) \)。 &lt;br/&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;若\( \varepsilon \in \mathrm{FIRST}(\beta) \)，或 \( B \rightarrow \alpha A \)（即 \( A \) 是末尾符号），则将 \( \mathrm{FOLLOW}(B) \) 加入 \( \mathrm{FOLLOW}(A) \)。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;重复直到各\( \mathrm{FOLLOW} \)集合不再变化为止。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;自顶向下&#34;&gt;自顶向下&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e8%87%aa%e9%a1%b6%e5%90%91%e4%b8%8b&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;递归向下 LL(k) 从左往右， 从语法树的生成来看是最左推导的。k表示向前看k个字符。 &lt;br/&gt;&#xA;和一般的递归算法一样，如果发生错误，则进行回溯。 &lt;br/&gt;&#xA;优化方法为修改文法，使其能做到唯一的推导，此时自然就没有错误率。 &lt;br/&gt;&#xA;需要一张预测分析表，递归调用隐式的进行状态管理。 &lt;br/&gt;&#xA;LL(1)算法： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;\begin{aligned}&#xA;&amp;amp;\text{word} \leftarrow \text{NextWord()} \\&#xA;&amp;amp;\text{push eof onto Stack} \\&#xA;&amp;amp;\text{push the start symbol } S \text{ onto Stack} \\&#xA;&amp;amp;\text{while (true) do} \\&#xA;&amp;amp;\quad \text{focus} \leftarrow \text{top of Stack} \\&#xA;&amp;amp;\quad \text{if (focus = eof and word = eof) then} \\&#xA;&amp;amp;\qquad \text{report success and break from the loop} \\&#xA;&amp;amp;\quad \text{else if (focus} \in T \text{ or focus = eof) then} \\&#xA;&amp;amp;\qquad \text{if (focus matches word) then} \\&#xA;&amp;amp;\qquad\quad \text{pop Stack} \\&#xA;&amp;amp;\qquad\quad \text{word} \leftarrow \text{NextWord()} \\&#xA;&amp;amp;\qquad \text{else report an error looking for the symbol in focus} \\&#xA;&amp;amp;\quad \text{else} \\&#xA;&amp;amp;\qquad \text{// focus is a nonterminal} \\&#xA;&amp;amp;\qquad \text{if Table[focus, word] is } A \rightarrow \beta_1 \beta_2 \ldots \beta_k \text{ then} \\&#xA;&amp;amp;\qquad\quad \text{pop Stack} \\&#xA;&amp;amp;\qquad\quad \text{for } i \leftarrow k \text{ to } 1 \text{ by } -1 \text{ do} \\&#xA;&amp;amp;\qquad\qquad \text{if } \beta_i \ne \varepsilon \text{ then} \\&#xA;&amp;amp;\qquad\qquad\quad \text{push } \beta_i \text{ onto Stack} \\&#xA;&amp;amp;\qquad \text{else report an error expanding focus}&#xA;\end{aligned}&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;h3 id=&#34;自底向上&#34;&gt;自底向上&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e8%87%aa%e5%ba%95%e5%90%91%e4%b8%8a&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;LR(k) 从左往右分析 最右推导 反向的生成语法树,左边终结符从语法树的叶子节点往上归约至根节点，若从时间顺序倒过来看，即自顶向下生成语法树，则是从最右侧的终结符最先生成。 &lt;br/&gt;&#xA;LR(1) LALR(1) SLR(1) LR(0)文法表示的语言，后一个为前一个的子集。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;基本概念&#34;&gt;基本概念&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;在自底向上的分析器（例如表驱动的 LR (1) 分析器）中，关键步骤是找到下一个 handle（句柄）。高效的句柄发现是实现高效自底向上分析的关键。 &lt;br/&gt;&#xA;LR (1) 分析器使用一个句柄识别自动机，这个自动机被编码在两个表中，传统上称为 Action 表和 Goto 表。 &lt;br/&gt;&#xA;使用项集(item set)形式的下推自动机管理状态。 &lt;br/&gt;&#xA;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/context-free-grammar/lr.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&#xA;该自动机使用移入归约管理状态栈，其包含两个组件：1个栈 ， 1个输入缓冲区 ； &lt;br/&gt;&#xA;主要由4 个操作组成： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;移入：将下一个输入 符号 移入 栈顶 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;规约 ：规约是对栈中的语法符号串进行规约，被规约的串右侧位于栈顶，语法分析器确定串左端 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;接收 ：宣布语法分析过程成功完成 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;报错 ：发现语法错误，执行错误恢复程序。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;LR(1)语法分析器的基本骨架： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;\begin{aligned}&#xA;&amp;amp;\text{push } \langle \text{INVALID}, \text{INVALID} \rangle \text{ onto the stack} \\&#xA;&amp;amp;\text{push } \langle \text{start symbol}, s_0 \rangle \text{ onto the stack} \\&#xA;&amp;amp;\text{word} \leftarrow \text{NextWord()} \\&#xA;&amp;amp;\text{while (true) do} \\&#xA;&amp;amp;\quad \text{state} \leftarrow \text{state from pair at top of stack} \\&#xA;&amp;amp;\quad \text{if } \text{Action}[\text{state}, \text{word}] = \text{“reduce } A \to \beta” \text{ then} \\&#xA;&amp;amp;\qquad \text{pop } |\beta| \text{ pairs from the stack} \\&#xA;&amp;amp;\qquad \text{state} \leftarrow \text{state from pair at top of stack} \\&#xA;&amp;amp;\qquad \text{push } \langle A, \text{Goto}[\text{state}, A] \rangle \text{ onto the stack} \\&#xA;&amp;amp;\quad \text{else if } \text{Action}[\text{state}, \text{word}] = \text{“shift } s_i” \text{ then} \\&#xA;&amp;amp;\qquad \text{push } \langle \text{word}, s_i \rangle \text{ onto the stack} \\&#xA;&amp;amp;\qquad \text{word} \leftarrow \text{NextWord()} \\&#xA;&amp;amp;\quad \text{else if } \text{Action}[\text{state}, \text{word}] = \text{“accept” and word = eof then} \\&#xA;&amp;amp;\qquad \text{break} \\&#xA;&amp;amp;\quad \text{else} \\&#xA;&amp;amp;\qquad \text{throw a syntax error} \\&#xA;&amp;amp;\text{report success /* executed the “accept” case */}&#xA;\end{aligned}&lt;/p&gt;&#xA;&lt;p&gt;这个算法解释 Action 表和 Goto 表，以在输入的逆右推导中找到连续的句柄。当它找到一个句柄〈A → β, k〉时，就将当前句型中位置 k 处的 β 归约为 A，也就是对部分构建的语法树的上层边界进行归约。解析器并不显式地构建语法树，而是把语法树上层边界的前缀保存在一个栈中。栈中的每个元素是一个对〈A, s〉，其中 A 是一个文法符号，s 是一个解析状态。状态串联起归约过程，形成整个解析过程。 &lt;br/&gt;&#xA;变量 word 保存了下一个符号的前瞻符号，也就是栈内容之后的第一个单词。 &lt;br/&gt;&#xA;为了找到下一个句柄，LR (1) 解析器将符号不断地移入栈，直到自动机发现句柄的右端就在栈顶。一旦找到句柄 A → β，解析器就执行归约，用 A 替代 β。解析器从栈中弹出 β 中的符号和对应的状态，然后将 A 和它的新状态压入栈中。Action 和 Goto 表将动作（移进和归约）和状态串联起来，以文法驱动的序列找到一个右推导（如果存在的话）。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;h4 id=&#34;构建自动机&#34;&gt;构建自动机&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%9e%84%e5%bb%ba%e8%87%aa%e5%8a%a8%e6%9c%ba&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;项集&lt;/p&gt;&#xA; &lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;在 LR (1) 解析器中，Action 和 Goto 表编码了每一步解析中句柄和潜在句柄的信息。表构造算法使用 LR (1) 项来表示句柄、潜在句柄以及相关的前瞻符号。 &lt;br/&gt;&#xA;LR (1) 项 ：[𝐴→𝛽•𝛾,𝑎] 包含产生式 𝐴→𝛽𝛾，一个指示栈顶位置的占位符 •，以及一个特定的终结符 a 作为前瞻符号。 &lt;br/&gt;&lt;/p&gt;&#xA; &lt;/div&gt;&#xA;&lt;p&gt;表构造算法构建 规范集合 𝐶𝐶={𝐶𝐶0,𝐶𝐶1,𝐶𝐶2,&amp;hellip;,𝐶𝐶𝑛}，其中每个 𝐶𝐶𝑖∈𝐶𝐶 代表解析器的一个有效配置或一个解析状态。 &lt;br/&gt;&#xA;它包含一个或多个LR(1)项，这些项代表了与该解析状态相对应的句柄或潜在句柄。 &lt;br/&gt;&#xA;对于产生式 𝐴→𝛽𝛾A→βγ 和前瞻符号 a，占位符 • 可能有三种不同的位置，每种对应不同的解释。若某个 𝐶𝐶𝑖  中包含该项，则表示解析器已看到的输入与文法中出现 A 后跟 a 是一致的。• 的位置区分了以下三种情况： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;[A→•βγ,a] 表示 A 是有效的，下一个识别的步骤是 β，这一步是发现 A 的一部分。我们称此项为 可能项；它表示对已看到输入的可能完成。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;[A→β•γ,a] 表示解析器已经从状态 [𝐴→•𝛽𝛾,𝑎] 进展到识别了 β。下一步的有效操作是识别 γ。我们称此项为 部分完成项。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;[A→βγ•,a] 表示解析器已经识别了 βγ，且在一个 A 后面跟着 a 的有效上下文中。如果前瞻符号是 a，那么该项是一个句柄，解析器可以将 βγ 归约为 A。我们称此项为 完成项。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;closure and goto&lt;/p&gt;&#xA;&lt;p&gt;为了构造 LR (1) 项的规范集合 CC，解析器生成器从解析器的初始状态开始， &lt;br/&gt;&#xA;即[Goal→•List,eof] &lt;br/&gt;&#xA;并构建一个所有潜在状态转移的模型。该算法将解析器的每个可能配置（或状态）表示为一组 LR (1) 项。 &lt;br/&gt;&#xA;算法对这些 LR (1) 项集执行两个操作：闭包（closure）和转移（transition）。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;闭包函数（closure） 完善一个状态；给定一组核心项，它会将该组隐含的相关 LR (1) 项全部加入集合中。例如，在任何允许 Goal→List 的地方，产生 𝐿𝑖𝑠𝑡 的产生式也是合法的。因此，项 [Goal→•List,eof] 同时隐含了[List→•List Pair,eof] 和 [List→•Pair,eof] 这两个项。闭包操作找到所有此类项并将它们加入当前状态。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;转移函数（goto） 模拟从某状态 𝑠 出发，读取文法符号 𝑥 后的状态转移效果。算法检查状态 𝑠 中的 LR (1) 项，找到所有 “•” 位置紧挨着 𝑥 的项，将 “•” 移动到 𝑥 之后，把新的项放入 goto 返回的新状态集合中。最后，对新状态再执行闭包操作以完成状态。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;为了方便找到起始符号，我们要求文法有唯一的起始符号，且该符号不出现在任何产生式的右侧。在这个括号文法中，该符号是 Goal。 &lt;br/&gt;&lt;/p&gt;&#xA; &lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;closure函数 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;\begin{aligned}&#xA;&amp;amp;\text{closure}(s) \\&#xA;&amp;amp;\text{while } s \text{ is still changing do} \\&#xA;&amp;amp;\quad \text{for each item } [A \to \beta \bullet C \delta, a] \in s \text{ do} \\&#xA;&amp;amp;\qquad \text{lookahead} \leftarrow \delta a \\&#xA;&amp;amp;\qquad \text{for each production } C \to \gamma \in P \text{ do} \\&#xA;&amp;amp;\qquad\quad \text{for each } b \in \text{FIRST}(\text{lookahead}) \text{ do} \\&#xA;&amp;amp;\qquad\qquad s \leftarrow s \cup \{ [C \to \bullet \gamma, b] \} \\&#xA;&amp;amp;\text{return } s&#xA;\end{aligned}&lt;/p&gt;&#xA; &lt;/div&gt;&#xA; &lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;goto函数： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;\begin{aligned}&#xA;&amp;amp;\text{goto}(s, x) \\&#xA;&amp;amp;t \leftarrow \emptyset \\&#xA;&amp;amp;\text{for each item } i \in s \text{ do} \\&#xA;&amp;amp;\quad \text{if } i \text{ is } [\alpha \to \beta \bullet x \delta, a] \text{ then} \\&#xA;&amp;amp;\qquad t \leftarrow t \cup \{[\alpha \to \beta x \bullet \delta, a]\} \\&#xA;&amp;amp;\text{return } \text{closure}(t)&#xA;\end{aligned}&lt;/p&gt;&#xA; &lt;/div&gt;&#xA; &lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;项集构建算法： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;\begin{aligned}&#xA;&amp;amp;CC_0 \leftarrow \emptyset \\&#xA;&amp;amp;\text{for each production of the form } \text{Goal} \to \alpha \text{ do} \\&#xA;&amp;amp;\quad CC_0 \leftarrow CC_0 \cup \{ [ \text{Goal} \to \bullet \alpha, \text{eof} ] \} \\&#xA;&amp;amp;CC_0 \leftarrow \text{closure}(CC_0) \\&#xA;&amp;amp;CC \leftarrow \{ CC_0 \} \\&#xA;&amp;amp;\text{while (new sets are still being added to } CC) \text{ do} \\&#xA;&amp;amp;\quad \text{for each unmarked set } CC_i \in CC \text{ do} \\&#xA;&amp;amp;\qquad \text{mark } CC_i \text{ as processed} \\&#xA;&amp;amp;\qquad \text{for each } x \text{ following a } \bullet \text{ in an item in } CC_i \text{ do} \\&#xA;&amp;amp;\qquad\quad \text{temp} \leftarrow \text{goto}(CC_i, x) \\&#xA;&amp;amp;\qquad\quad \text{if } \text{temp} \notin CC \text{ then} \\&#xA;&amp;amp;\qquad\qquad CC \leftarrow CC \cup \{\text{temp}\} \\&#xA;&amp;amp;\qquad\qquad \text{record transition from } CC_i \text{ to temp on } x&#xA;\end{aligned}&lt;/p&gt;&#xA; &lt;/div&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;语法分析表&#34;&gt;语法分析表&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e8%a1%a8&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;\begin{aligned}&#xA;&amp;amp;CC_0 \leftarrow \emptyset \\&#xA;&amp;amp;\text{for each production of the form } \text{Goal} \to \alpha \text{ do} \\&#xA;&amp;amp;\quad CC_0 \leftarrow CC_0 \cup \{ [\text{Goal} \to \bullet \alpha, \text{eof}] \} \\&#xA;&amp;amp;CC_0 \leftarrow \text{closure}(CC_0) \\&#xA;&amp;amp;CC \leftarrow \{ CC_0 \} \\&#xA;&amp;amp;\text{while (new sets are still being added to } CC) \text{ do} \\&#xA;&amp;amp;\quad \text{for each unmarked set } CC_i \in CC \text{ do} \\&#xA;&amp;amp;\qquad \text{mark } CC_i \text{ as processed} \\&#xA;&amp;amp;\qquad \text{for each } x \text{ following a } \bullet \text{ in an item in } CC_i \text{ do} \\&#xA;&amp;amp;\qquad\quad \text{temp} \leftarrow \text{goto}(CC_i, x) \\&#xA;&amp;amp;\qquad\quad \text{if } \text{temp} \notin CC \text{ then} \\&#xA;&amp;amp;\qquad\qquad CC \leftarrow CC \cup \{ \text{temp} \} \\&#xA;&amp;amp;\qquad\quad \text{record transition from } CC_i \text{ to temp on } x&#xA;\end{aligned}&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;</description>
    </item>
    <item>
      <title>Llvm Backend</title>
      <link>https://qisc123.github.io/posts/2024/04/llvm-backend/</link>
      <pubDate>Wed, 24 Apr 2024 20:29:00 +0800</pubDate>
      <guid>https://qisc123.github.io/posts/2024/04/llvm-backend/</guid>
      <description>&lt;h2 id=&#34;后端&#34;&gt;后端&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%90%8e%e7%ab%af&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;概述&#34;&gt;概述&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%a6%82%e8%bf%b0&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;figure&gt;&lt;img data-src=&#34;https://qisc123.github.io/imgs/llvm-backend.png&#34;&#xA;         data-action=&#34;zoom&#34;&#xA;         class=&#34;lazyload&#34;/&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;将LLVM IR转换为目标汇编代码需要经历若干步骤。IR被变换为后端友好的指令、函数、全局变量的表示。这种表示随着程序经历各种后端阶段而变化，越来越接近实际的目标指令。上图给出了必需的步骤的概观，从LLVM IR到目标代码或者汇编。&#xA;白色框：非必需的优化Pass以进一步改进翻译的质量。&#xA;浅灰色的中间框：它们在内部也称为super pass，因为它们由若干小的Pass实现。它们和白色框的区别在于，前者这些Pass对后端的成功很关键，而后者对于提高所生成的代码的效率更重要。&lt;/p&gt;&#xA;&lt;h4 id=&#34;指令选择-instructionselection&#34;&gt;指令选择（InstructionSelection）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%8c%87%e4%bb%a4%e9%80%89%e6%8b%a9-instructionselection&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;过程将内存中的IR表示变换为目标特定的SelectionDAG节点。起初，这个过程将三地址结构的LLVM IR变换为DAG（Directed Acyclic Graph）形式，这是有向无环图。每个DAG能够表示单一基本块的计算，这意味着每个基本块关联不同的DAG。典型地节点表示指令，而边编码了它们之间的数据流依赖，但不限于此。转换为DAG是重要的，这让LLVM代码生成程序库能够运用基于树的模式匹配指令选择算法，它经过一些调整，也能工作在DAG上（而不仅仅是树）。到这个过程结束时，DAG已将它所有的LLVM IR节点变换为目标机器节点，这些节点表示机器指令而不是LLVM指令。&lt;/p&gt;&#xA;&lt;p&gt;指令选择之后，对于使用哪些目标指令执行每个基本块的计算，我们已经有了清楚的概念。这编码在SelectionDAG类中。然而，我们需要返回三地址表示形式，以决定基本块内部的指令顺序，因为DAG并不暗示互不依赖的指令之间的顺序。&lt;/p&gt;&#xA;&lt;h4 id=&#34;第1次指令调度-instruction-scheduling&#34;&gt;第1次指令调度（Instruction Scheduling）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e7%ac%ac1%e6%ac%a1%e6%8c%87%e4%bb%a4%e8%b0%83%e5%ba%a6-instruction-scheduling&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;也称为前寄存器分配（RA）调度，对指令排序，同时尝试发现尽可能多的指令层次的并行。然后这些指令被变换为MachineInstr三地址表示。&#xA;回想一下，LLVM IR的寄存器集是无限的。这个性质一直保持着，直到寄存器分配（Register Allocation）&#xA;它将无限的虚拟寄存器的引用转换为有限的目标特定的寄存器集，寄存器不够时挤出（spill）到内存。&lt;/p&gt;&#xA;&lt;h4 id=&#34;第2次指令调度&#34;&gt;第2次指令调度&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e7%ac%ac2%e6%ac%a1%e6%8c%87%e4%bb%a4%e8%b0%83%e5%ba%a6&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;也称为后寄存器分配（RA）调度，在此时发生。因为此时在这个点可获得真实的寄存器信息，某些类型寄存器存在额外的风险和延迟，它们可被用以改进指令顺序。&lt;/p&gt;&#xA;&lt;h4 id=&#34;代码输出-code-emission&#34;&gt;代码输出（Code Emission）&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e4%bb%a3%e7%a0%81%e8%be%93%e5%87%ba-code-emission&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;阶段将指令从MachineInstr表示变换为MCInst实例。这种新的表示更适合汇编器和链接器，它有两种选择：输出汇编代码或者输出二进制块（blob）到一种特定的目标代码格式。如此，整个后端流水线用到了四种不同层次的指令表示：内存中的LLVM IR，SelectionDAG节点，MachineInstr，和MCInst。&lt;/p&gt;&#xA;&lt;h3 id=&#34;llc-后端工具&#34;&gt;llc 后端工具&lt;a class=&#34;anchorjs-link&#34; href=&#34;#llc-%e5%90%8e%e7%ab%af%e5%b7%a5%e5%85%b7&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;llc的工作 生成汇编或可执行代码&lt;/p&gt;&#xA;&lt;h4 id=&#34;ir具有目标相关性&#34;&gt;IR具有目标相关性&lt;a class=&#34;anchorjs-link&#34; href=&#34;#ir%e5%85%b7%e6%9c%89%e7%9b%ae%e6%a0%87%e7%9b%b8%e5%85%b3%e6%80%a7&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;在第5章（LLVM中间表示）中，我们解释了IR具有目标相关的一面，尽管它是为所有后端设计的共同语言。因为C/C++语言具有目标相关的属性，所以这种相关性会体现在LLVM IR中。&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;一个例子。&lt;/p&gt;&#xA;&lt;p&gt;考虑你的程序分配了char指针的一个vector，用以存储不同的字符串，你用通用的C语句malloc(sizeof(char*)*n)来为字符串vector分配内存。如果你在前端时指定了目标，比如32位MIPS架构，它生成的代码会让malloc分配n x 4字节的内存，因为在32位MIPS上每个指针是4字节。然而，如果你用llc编译这个bitcode而强制指定x86_64架构，它将生成坏的程序。在运行时，会发生潜在的分段错误（segmentation fault），因为x86_64架构的每个指针是8字节，这使得malloc分配的内存不足够。在x86_64上正确的malloc调用将分配n x 8字节。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;后端代码结构&#34;&gt;后端代码结构&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%90%8e%e7%ab%af%e4%bb%a3%e7%a0%81%e7%bb%93%e6%9e%84&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;代码生成背后的主要程序库位于lib目录和它的子文件夹CodeGen、MC、TableGen、和Target中：&lt;/p&gt;&#xA;&lt;p&gt;CodeGen目录包含的文件和头文件实现了所有通用的代码生成算法：指令选择，指令调度，寄存器分配，和所有它们需要的分析。&lt;/p&gt;&#xA;&lt;p&gt;MC目录实现了低层次功能，包括汇编器（汇编解析器）、松弛算法（反汇编器）、和特定的目标文件格式如ELF、COFF、Macho等等。&lt;/p&gt;&#xA;&lt;p&gt;TableGen目录包含TableGen工具的完整实现，它可以根据.td文件中的高层次的目标描述生成C++代码。&lt;/p&gt;&#xA;&lt;p&gt;每个目标的实现在Target的子文件夹中，如Target/Mips，包括若干.cpp、.h、和.td文件。为不同目标实现类似功能的文件倾向于共用类似的名字。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Finite Automata</title>
      <link>https://qisc123.github.io/posts/2024/04/finite-automata/</link>
      <pubDate>Sat, 20 Apr 2024 00:00:00 +0800</pubDate>
      <guid>https://qisc123.github.io/posts/2024/04/finite-automata/</guid>
      <description>&lt;h2 id=&#34;dfa&#34;&gt;DFA&lt;a class=&#34;anchorjs-link&#34; href=&#34;#dfa&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;一台有穷自动机有若干部分: &lt;br/&gt;&#xA;一个状态集和根据输入符号从一个状态到另一个状态的规则。 &lt;br/&gt;&#xA;一个输入字母表，指明所有允许的输入符号。 &lt;br/&gt;&#xA;一个起始状态和一个接受状态集。 &lt;br/&gt;&#xA;形式化定义把一台有穷自动机描述成一张含以下5部分的表：状态集、输入字母表、动作规则、起始状态以及接受状态集。用数学语言表达，5个元素的表经常称为5元组。因此，定义有穷自动机是由这5部分组成的5元组。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;用转移函数（transition function）定义动作规则，常记作δ。如果有穷自动机有从状态x到状态y标有输入符号1的箭头，这表示当它处于状态x时读到1，则转移到状态y。可以用转移函数讲清楚这件事，记作δ(x，1)=y。这个记号是一种数学简写方式。把这些结合在一起得到有穷自动机的形式化定义。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;定义&#34;&gt;定义&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%ae%9a%e4%b9%89&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;&lt;strong&gt;(DFA)&lt;/strong&gt; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;*确定性有穷状态自动机*（Deterministic finite automata，DFA）是一个五元组： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;\[M = (Q, \Sigma, \delta, q_0, F)\] &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;\(Q\)：状态（state）的非空有穷集合 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(\Sigma\)：输入字母表（input alphabet） &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(\delta\)：状态转移函数（transition function） &lt;br/&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;\(\delta : Q \times \Sigma \rightarrow Q\) &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(\delta(q, a) = p\) 表示 \(M\) 在状态 \(q\) 下读入字符 \(a\)，则将状态转移到 \(p\) 并将读头指向下一字符串 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;\(q_0\)：开始状态（initial state），\(q_0 \in Q\) &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(F\)：终止状态（final state）或接受状态（accept state），\(F \subseteq Q\) &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;nfa&#34;&gt;NFA&lt;a class=&#34;anchorjs-link&#34; href=&#34;#nfa&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;与DFA的最大区别是对于一个输入，NFA有多个转移。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;定义&#34;&gt;定义&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%ae%9a%e4%b9%89&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;&lt;strong&gt;(NFA)&lt;/strong&gt; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;*非确定性有穷状态自动机*（non-deterministic finite automaton，NFA） &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;\[M =(Q, \Sigma, \delta, q_0, F)\] &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;\(Q, \Sigma, q_0, F\) 的意义与 DFA 相同 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(\delta: Q \times \Sigma \rightarrow 2^Q\) &lt;br/&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;\(\delta(q, a) = \{p_1, p_2, \cdots p_m\} | p_i \subseteq Q\) 表示 \(M\) 在状态 \(q\) 下读入字符 \(a\)，可以将状态转移到 \(p_i\) 并指向下一个字符 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;varepsilon-nfa&#34;&gt;\(\varepsilon\)-NFA&lt;a class=&#34;anchorjs-link&#34; href=&#34;#varepsilon-nfa&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;即带有空转移的NFA。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;定义&#34;&gt;定义&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e5%ae%9a%e4%b9%89&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;&lt;strong&gt;(\(\varepsilon\)-NFA)&lt;/strong&gt; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;*带空转移的非确定性有穷状态自动机*（non-deterministic finite automaton with \(\varepsilon\) moves，\(\varepsilon\)-NFA） &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;\[M =(Q, \Sigma, \delta, q_0, F)\] &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;\(Q, \Sigma, q_0, F\) 的意义与 DFA 相同 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;\(\delta: Q \times (\Sigma \cup \{ \varepsilon \}) \rightarrow 2^Q\) &lt;br/&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于 \(\delta(q, s) = \{p_1, p_2, \cdots p_m\}\) 表示 \(M\) 在状态 \(q\) 下读入字符 \(a\)，则可以将状态转移到 \(p_i\) 并将读头指向下一个字符 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;对于 \(\delta(q, \varepsilon) = \{p_1, p_2, \cdots p_m\}\) 表示 \(M\) 在状态 \(q\) 下不读入字符，并将状态转移到 \(p_i\) &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;正则表达式&#34;&gt;正则表达式&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;假设有一个字母表 \(\Sigma\)，正则表达式描述了 $Σ$字符（外加表示空串的特殊字符\(\varepsilon\)）构成的字符串集合。由正则表达式定义的字符串集合称为一个语言，记作\(L( r)\)（其中 \(r\) 为某个正则表达式）。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;正则表达式由以下三种基本运算构成： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Alternation：或操作，记作\(r \mid s\)，其语言为\(\{ x \mid x \in L( r) \lor x \in L(s) \}\)。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Concatenation：并操作，记作 \(rs\)，即\(\{ xy \mid x \in L( r) \land y \in L(s) \}\)。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Closure：\(r\) 的柯林闭包（Kleene closure），记作 \(r^*\)，定义为\(\bigcup\limits_{i=0}^{\infty} r^i\)。 \(L(r^*)\) 包含由 \(L( r)\) 中的字符串通过零次或多次连接构成的所有字符串。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;正则语言与-fa&#34;&gt;正则语言与 FA&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e6%ad%a3%e5%88%99%e8%af%ad%e8%a8%80%e4%b8%8e-fa&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;rl-与-fa-等价&#34;&gt;RL 与 FA 等价&lt;a class=&#34;anchorjs-link&#34; href=&#34;#rl-%e4%b8%8e-fa-%e7%ad%89%e4%bb%b7&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;div class=&#34;theorem&#34;&gt;&#xA;&lt;p&gt;RL 与 FA 等价。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;proof&#34;&gt;&#xA;&lt;p&gt;只要证明 RL \(\subseteq\) FA，且 FA \(\subseteq\) RL 即可。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;首先证明 FA 能够接受 RL。需要对于任意 RL，要构造一个与之等价的 FA。对于正则文法 \(G = (V, T, P, S)\)，构造 \(M = (V \cup \{Z\}, T, \delta, S, \{Z\})\)，其中 \(\delta\) 的定义如下： &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;\[\delta(A, a) =&#xA;\begin{cases}&#xA;\{B | A \rightarrow aB \in P\} \cup \{Z\}, &amp;amp; A \rightarrow a \in P \\&#xA;\{B | A \rightarrow aB \in P\} , &amp;amp; A \rightarrow a \notin P&#xA;\end{cases}\] &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;下面证明 \(L(M) = L(G)\)。设 \(a_1 a_2 \dots a_n \in L(G)\)，即有推导 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;\begin{aligned}&#xA;&amp;amp; S \xRightarrow{+} a_1 a_2 \dots a_n \\&#xA;\Leftrightarrow&amp;amp; S \Rightarrow a_1 A_1 \Rightarrow a_1 a_2 A_2 \Rightarrow \dots \Rightarrow a_1 a_2 \dots a_n&#xA;\end{aligned}&lt;/p&gt;&#xA;&lt;p&gt;因此 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;\begin{aligned}&#xA;&amp;amp; S \rightarrow a_1 A_1 \in P \\&#xA;&amp;amp; A_1 \rightarrow a_2 A_2 \in P \\&#xA;&amp;amp; \dots \\&#xA;&amp;amp; A_{n-2} \rightarrow a_{n-1} A_{n-1} \in P \\&#xA;&amp;amp; A_{n-1} \rightarrow a_n \in P&#xA;\end{aligned}&lt;/p&gt;&#xA;&lt;p&gt;根据此文法，对于 \(\delta\) 有 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;\begin{aligned}&#xA;&amp;amp; A_1 \in \delta(S, a_1) \\&#xA;&amp;amp; A_2 \in \delta(A_1, a_2) \\&#xA;&amp;amp; \dots \\&#xA;&amp;amp; A_{n-1} \in \delta(A_{n-2}, a_{n-1}) \\&#xA;&amp;amp; Z \in \delta(A_{n-1}, a_n)&#xA;\end{aligned}&lt;/p&gt;&#xA;&lt;p&gt;因此 \(Z \in \delta(S, a_1 a_2 \dots a_n)\)，成立。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;这里需要特殊处理 \(\varepsilon\) 的情况。不妨假设 \(S\) 不出现在任何产生式的右部。设 \(S \rightarrow \varepsilon \in P\)，则定义转移 \(\delta(S, \varepsilon) = \{Z\}\)，由于 \(S\) 不出现在产生式的右部，因此 FA 上的转移无法回到 \(S\)，即这个转移不会对其他句子的接受产生影响。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;下面证明 FA 接受的句子都是 RL。由于三种 FA 等价，因此这里只需要证明 DFA 接受的句子是 RL。设 DFA \(M = (Q, \Sigma, \delta, q_0, F)\)，构造 \(G = (Q, \Sigma, P, q_0)\)，其中 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;\[P = \{ q \rightarrow a p | \delta(q, a) = p \} \cup \{q \rightarrow a | \delta(q, a) = p \in F \}\] &lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;证明类似。同样这里需要考虑 \(\varepsilon\) 相关的句子。假设 \(q_0 \notin F\)，则 \(\varepsilon \notin L(M)\)，不影响。如果 \(q_0 \in F\)，由于空句子存在与否不影响语言性质，因此存在正则文法 \(G&amp;rsquo;\) 使得 \(L(G&amp;rsquo;) = L(G) \cup \{\varepsilon\} = L(M)\)。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;综上，命题成立。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;从正则表达式到dfa&#34;&gt;从正则表达式到DFA&lt;a class=&#34;anchorjs-link&#34; href=&#34;#%e4%bb%8e%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e5%88%b0dfa&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;figure&gt;&lt;img data-src=&#34;https://qisc123.github.io/imgs/automata/transform.png&#34;&#xA;         data-action=&#34;zoom&#34;&#xA;         class=&#34;lazyload&#34;/&gt;&#xA;&lt;/figure&gt;&#xA; &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用Thompson构造法，从RE构造出一个NFA &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;figure&gt;&#xA;  &lt;a class=&#34;paragraph-image&#34;&gt;&#xA;    &lt;img data-src=&#34;https://qisc123.github.io/imgs/automata/re2NFA.png&#34; data-action=&#34;zoom&#34; alt=&#34;&#34;  class=&#34;lazyload&#34;&gt;&#xA;  &lt;/a&gt;&#xA;  &#xA;&lt;/figure&gt; &lt;br/&gt;&#xA;由Thompson构造法生成的NFA具有一些特定的性质，这些性质简化了其实现过程。每个NFA都有一个开始状态和一个接受状态。 &lt;br/&gt;&#xA;除了初始转换外，没有任何转换会进入开始状态；也没有任何转换会从接受状态离开。 &lt;br/&gt;&#xA;最后，每个状态最多有两个ε转换的进入和两个ε转换的离开，并且在字母表中的某个符号上，最多只有一个进入和一个离开转换。所有这些性质共同简化了NFA的表示和操作。 &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用子集构造法将NFA转化为DFA &lt;br/&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;FollowEpsilon(n)表示从n出发经过一个或多个\(\varepsilon\)转换所能到达的状态集合加上n。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;Delta(q,c) q为一个集合，初始值为q0,返回q中所有元素应用对应状态转移函数所能到达状态的集合。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;核心思想是尽可能的将NFA中的状态集对应到DFA中的单个状态。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;li&gt;算法主体是数据流分析中十分常用的不动点迭代，不停的减小问题规模，直到集合为空。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;\begin{array}{l}&#xA;q_0 \gets \text{FollowEpsilon}(\{n_0\}) \\&#xA;Q \gets q_0 \\&#xA;\text{WorkList} \gets \{ q_0 \} \\&#xA;\textbf{while } \text{WorkList} \neq \emptyset \text{ do} \\&#xA;\quad \text{remove } q \text{ from WorkList} \\&#xA;\quad \textbf{for each character } c \in \Sigma \text{ do} \\&#xA;\quad\quad \text{temp} \gets \text{FollowEpsilon}(Delta(q, c)) \\&#xA;\quad\quad \textbf{if } \text{temp} \neq \emptyset \text{ then} \\&#xA;\quad\quad\quad \textbf{if } \text{temp} \notin Q \text{ then} \\&#xA;\quad\quad\quad\quad \text{add temp to both } Q \text{ and WorkList} \\&#xA;\quad\quad\quad \textbf{end if} \\&#xA;\quad\quad\quad T[q, c] \gets \text{temp} \\&#xA;\quad\quad \textbf{end if} \\&#xA;\quad \textbf{end for} \\&#xA;\textbf{end while}&#xA;\end{array}&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;最小化DFA &lt;br/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;关键在于检测DFA中的两个状态是否相等，如果这两个状态对于所有的输入a,都有同样的行为，那么这两个状态相等，可以合并。 &lt;br/&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;\begin{array}{l}&#xA;\text{Partition} \leftarrow \{ D - D_A \} \\&#xA;\text{Worklist} \leftarrow \{  D - D_A \} \\&#xA;\textbf{while } \text{Worklist} \neq \emptyset \textbf{ do} \\&#xA;\quad \text{select a set } s \text{ from Worklist and remove it} \\&#xA;\quad \textbf{for each character } c \in \Sigma \textbf{ do} \\&#xA;\quad\quad \text{Image} \leftarrow \{ x \mid \delta(x, c) \in s \} \\&#xA;\quad\quad \textbf{for each set } q \in \text{Partition that has a state in Image do} \\&#xA;\quad\quad\quad q_1 \leftarrow q \cap \text{Image} \\&#xA;\quad\quad\quad q_2 \leftarrow q - q_1 \\&#xA;\quad\quad\quad \textbf{if } q_2 \neq \emptyset \textbf{ then} \\&#xA;\quad\quad\quad\quad \text{remove } q \text{ from Partition} \\&#xA;\quad\quad\quad\quad \text{Partition} \leftarrow \text{Partition} \cup \{ q_1, q_2 \} \\&#xA;\quad\quad\quad\quad \textbf{if } q \in \text{Worklist then} \\&#xA;\quad\quad\quad\quad\quad \text{remove } q \text{ from Worklist} \\&#xA;\quad\quad\quad\quad\quad \text{Worklist} \leftarrow \text{Worklist} \cup \{ q_1, q_2 \} \\&#xA;\quad\quad\quad\quad \textbf{else if } |q_1| \leq |q_2| \textbf{ then} \\&#xA;\quad\quad\quad\quad\quad \text{Worklist} \leftarrow \text{Worklist} \cup \{ q_1 \} \\&#xA;\quad\quad\quad\quad \textbf{else} \\&#xA;\quad\quad\quad\quad\quad \text{Worklist} \leftarrow \text{Worklist} \cup \{ q_2 \} \\&#xA;\quad\quad\quad\quad \textbf{if } s = q \textbf{ then break} \\&#xA;\end{array}&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
  </channel>
</rss>
